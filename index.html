<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#3498db">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="æ—¥æ–‡N4æ¸¬é©—">

    <!-- Icons -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ“š</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ“š</text></svg>">
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥æ–‡N4å–®å­—èˆ‡æ–‡æ³•æ¸¬é©—ç³»çµ±</title>
    <style>
    * {
        box-sizing: border-box;
        font-family: "Microsoft JhengHei", "Segoe UI", sans-serif;
    }
    body {
        background-color: #f5f5f5;
        margin: 0;
        padding: 20px;
        color: #333;
        line-height: 1.6;
    }
    .container {
        max-width: 800px;
        margin: 0 auto;
        background: white;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        padding: 25px;
        position: relative;
    }
    h1 {
        color: #2c3e50;
        text-align: center;
        margin-bottom: 30px;
        border-bottom: 2px solid #eee;
        padding-bottom: 15px;
    }
    .home-screen, .quiz-screen, .result-screen, .history-screen {
        display: none;
    }
    .home-screen.active, .quiz-screen.active, .result-screen.active, .history-screen.active {
        display: block;
    }
    .home-buttons {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-top: 30px;
    }
    .home-btn {
        padding: 15px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 18px;
        transition: background-color 0.3s;
    }
    .home-btn:hover {
        background-color: #2980b9;
    }
    .home-btn.exit {
        background-color: #e74c3c;
    }
    .home-btn.exit:hover {
        background-color: #c0392b;
    }
    .home-btn.update {
        background-color: #2ecc71;
    }
    .home-btn.update:hover {
        background-color: #27ae60;
    }
    
    /* æ¸¬é©—é¡å‹é¸æ“‡æŒ‰éˆ•æ¨£å¼ */
    .count-buttons-container {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        margin-top: 15px;
    }
    .count-btn {
        margin: 0;
        padding: 15px 10px;
        background-color: #95a5a6;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s ease;
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
    }
    .count-btn.active {
        background-color: #2ecc71;
        font-weight: bold;
        transform: scale(1.02);
        box-shadow: 0 4px 8px rgba(46, 204, 113, 0.3);
    }
    .count-btn:hover {
        background-color: #7f8c8d;
        transform: translateY(-2px);
    }
    .count-btn.active:hover {
        background-color: #27ae60;
    }
    
    /* é¡Œç›®æ•¸é‡è¼¸å…¥æ¡† */
    .question-count-input {
        margin: 20px 0;
        text-align: center;
    }
    .question-count-input label {
        display: block;
        margin-bottom: 10px;
        font-weight: bold;
        color: #2c3e50;
    }
    .question-count-input input {
        width: 100%;
        padding: 12px;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 16px;
        text-align: center;
    }
    
    .question {
        margin-bottom: 25px;
        padding: 15px;
        border-radius: 8px;
        background-color: #f9f9f9;
    }
    .question-number {
        font-weight: bold;
        color: #3498db;
        margin-bottom: 10px;
    }
    .question-text {
        font-size: 18px;
        margin-bottom: 15px;
        line-height: 1.5;
    }
    .kanji {
        font-size: 24px;
        font-weight: bold;
        color: #e74c3c;
        margin: 10px 0;
        text-align: center;
    }
    .options {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    .option {
        padding: 12px 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.2s;
    }
    .option:hover {
        background-color: #f0f0f0;
    }
    .option.selected {
        background-color: #d6eaf8;
        border-color: #3498db;
    }
    .option.correct {
        background-color: #d4edda;
        border-color: #28a745;
    }
    .option.incorrect {
        background-color: #f8d7da;
        border-color: #dc3545;
    }
    .explanation {
        margin-top: 15px;
        padding: 15px;
        background-color: #e8f4fc;
        border-radius: 5px;
        display: none;
    }
    .explanation.show {
        display: block;
    }
    .explanation-title {
        font-weight: bold;
        color: #2c3e50;
        margin-bottom: 8px;
    }
    .option-explanation {
        margin-top: 10px;
        padding: 8px;
        background-color: #f8f9fa;
        border-radius: 4px;
        font-size: 14px;
    }
    .button-container {
        display: flex;
        justify-content: center;
        margin-top: 30px;
        gap: 15px;
        flex-wrap: wrap;
    }
    button {
        padding: 12px 25px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s;
    }
    button:hover {
        background-color: #2980b9;
    }
    button:disabled {
        background-color: #bdc3c7;
        cursor: not-allowed;
    }
    button.restart {
        background-color: #e67e22;
    }
    button.restart:hover {
        background-color: #d35400;
    }
    .stats {
        text-align: center;
        margin-bottom: 20px;
        font-size: 18px;
        color: #2c3e50;
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
    }
    .timer {
        font-weight: bold;
        color: #e74c3c;
    }
    .result {
        text-align: center;
        margin-top: 20px;
        padding: 15px;
        border-radius: 8px;
        background-color: #e8f4fc;
    }
    .result-title {
        font-weight: bold;
        font-size: 20px;
        margin-bottom: 10px;
        color: #2c3e50;
    }
    .wrong-questions {
        margin-top: 20px;
        text-align: left;
    }
    .wrong-title {
        font-weight: bold;
        margin-bottom: 10px;
        color: #e74c3c;
    }
    .history-list {
        margin-top: 20px;
    }
    .history-item {
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        margin-bottom: 10px;
        background-color: #f9f9f9;
    }
    .history-date {
        font-weight: bold;
        color: #2c3e50;
    }
    .history-stats {
        display: flex;
        justify-content: space-between;
        margin-top: 10px;
        flex-wrap: wrap;
    }
    .history-stat {
        flex: 1;
        min-width: 120px;
        text-align: center;
        padding: 5px;
    }
    .question-count-selector {
        margin: 20px 0;
        text-align: center;
    }
    .loading {
        opacity: 0.6;
        pointer-events: none;
    }
    .error-message {
        background-color: #f8d7da;
        color: #721c24;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
        text-align: center;
    }
    .success-message {
        background-color: #d4edda;
        color: #155724;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
        text-align: center;
    }
    .update-indicator {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 10px;
        height: 10px;
        background-color: #2ecc71;
        border-radius: 50%;
        z-index: 1001;
        animation: pulse 2s infinite;
    }
    .update-indicator.outdated {
        background-color: #e74c3c;
    }
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
    }
    
    /* æ‰‹æ©Ÿç‰ˆæ¨£å¼ */
    @media (max-width: 768px) {
        .container {
            padding: 15px;
            margin: 10px;
            border-radius: 8px;
        }
        h1 {
            font-size: 24px;
            margin-bottom: 20px;
        }
        .home-btn, button {
            padding: 18px;
            font-size: 16px;
        }
        .question-text {
            font-size: 16px;
        }
        .kanji {
            font-size: 20px;
        }
        .option {
            padding: 15px;
            font-size: 16px;
            min-height: 44px;
            display: flex;
            align-items: center;
        }
        .button-container {
            flex-direction: column;
            gap: 10px;
        }
        .button-container button {
            width: 100%;
        }
        .history-stats {
            flex-direction: column;
        }
        .history-stat {
            min-width: 100%;
            text-align: left;
            margin-bottom: 5px;
        }
        .stats {
            flex-direction: column;
            gap: 10px;
        }
        .count-buttons-container {
            grid-template-columns: 1fr;
            gap: 10px;
        }
        .count-btn {
            padding: 18px 15px;
            font-size: 18px;
            min-height: 60px;
        }
        .question-count-selector p {
            font-size: 18px;
            margin-bottom: 15px;
        }
    }
    
    /* é˜²æ­¢æ‰‹æ©Ÿä¸Šé»æ“Šé«˜äº® */
    * {
        -webkit-tap-highlight-color: transparent;
    }
    /* æ”¹å–„è§¸æ‘¸é«”é©— */
    button, .option {
        touch-action: manipulation;
    }
    </style>
</head>
<body>
    <div class="container">
        <div class="update-indicator" id="update-indicator"></div>
        <h1>æ—¥æ–‡N4å–®å­—èˆ‡æ–‡æ³•æ¸¬é©—ç³»çµ±</h1>
        
        <!-- é¦–é  -->
        <div id="home-screen" class="home-screen active">
            <div class="home-buttons">
                <button id="start-quiz-btn" class="home-btn">é–‹å§‹æ¸¬é©—</button>
                <button id="update-btn" class="home-btn update">æª¢æŸ¥é¡Œåº«æ›´æ–°</button>
                
                <div class="question-count-selector">
                    <p>é¸æ“‡æ¸¬é©—é¡å‹ï¼š</p>
                    <div class="count-buttons-container">
                        <button id="count-simulate-btn" class="count-btn active">æ¨¡æ“¬N4è€ƒé¡Œ</button>
                        <button id="count-past-btn" class="count-btn">æ­·å±†è€ƒé¡Œ</button>
                        <button id="count-vocab-btn" class="count-btn">å–®å­—æ¸¬é©—</button>
                    </div>
                    
                    <div class="question-count-input">
                        <label for="question-count">é¡Œç›®æ•¸é‡ï¼š</label>
                        <input type="number" id="question-count" min="1" max="100" value="30">
                    </div>
                </div>
                
                <button id="view-history-btn" class="home-btn">æ­·å²ç´€éŒ„æŸ¥è©¢</button>
                <button id="exit-btn" class="home-btn exit">çµæŸæ¸¬é©—</button>
            </div>
        </div>
        
        <!-- æ¸¬é©—é é¢ -->
        <div id="quiz-screen" class="quiz-screen">
            <div class="stats">
                <span id="progress">ç¬¬ 1 é¡Œ / å…± 10 é¡Œ</span>
                <span id="score">å¾—åˆ†: 0/0</span>
                <span id="timer" class="timer">æ™‚é–“: 00:00</span>
            </div>
            
            <div id="quiz-container">
                <!-- é¡Œç›®å°‡ç”±JavaScriptå‹•æ…‹ç”Ÿæˆ -->
            </div>
            
            <div class="button-container">
                <button id="prev-btn" disabled>ä¸Šä¸€é¡Œ</button>
                <button id="next-btn">ä¸‹ä¸€é¡Œ</button>
                <button id="submit-btn" style="display: none;">æäº¤ç­”æ¡ˆ</button>
                <button id="back-home-btn" class="restart">è¿”å›é¦–é </button>
            </div>
        </div>
        
        <!-- çµæœé é¢ -->
        <div id="result-screen" class="result-screen">
            <div id="result" class="result">
                <!-- æ¸¬é©—çµæœå°‡åœ¨é€™è£¡é¡¯ç¤º -->
            </div>
            
            <div class="button-container">
                <button id="restart-btn" class="restart">é‡æ–°é–‹å§‹æ¸¬é©—</button>
                <button id="result-back-home-btn">è¿”å›é¦–é </button>
            </div>
        </div>
        
        <!-- æ­·å²ç´€éŒ„é é¢ -->
        <div id="history-screen" class="history-screen">
            <h2>æ¸¬é©—æ­·å²ç´€éŒ„</h2>
            
            <div id="history-list" class="history-list">
                <!-- æ­·å²ç´€éŒ„å°‡åœ¨é€™è£¡é¡¯ç¤º -->
            </div>
            
            <div class="button-container">
                <button id="history-back-home-btn">è¿”å›é¦–é </button>
                <button id="clear-history-btn" class="restart">æ¸…é™¤æ­·å²ç´€éŒ„</button>
            </div>
        </div>
    </div>

    <script>
        // æ‡‰ç”¨ç‹€æ…‹
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let isAnswered = [];
        let score = 0;
        let wrongQuestions = [];
        let selectedQuestions = [];
        let shuffledQuestions = [];
        let questionCount = 30;
        let isPastQuestions = false;
        let isVocabMode = false;
        let timerInterval = null;
        let startTime = null;
        let elapsedTime = 0;
        let history = JSON.parse(localStorage.getItem('n4QuizHistory')) || [];
        
        // é¡Œåº«è³‡æ–™ (å°‡å¾å¤–éƒ¨JSæ–‡ä»¶è¼‰å…¥)
        let questionBank = [];
        let pastQuestionBank = [];
        let vocabBank = [];

        // DOMå…ƒç´ 
        const countSimulateBtn = document.getElementById('count-simulate-btn');
        const countPastBtn = document.getElementById('count-past-btn');
        const countVocabBtn = document.getElementById('count-vocab-btn');
        const questionCountInput = document.getElementById('question-count');
        const homeScreen = document.getElementById('home-screen');
        const quizScreen = document.getElementById('quiz-screen');
        const resultScreen = document.getElementById('result-screen');
        const historyScreen = document.getElementById('history-screen');
        const updateIndicator = document.getElementById('update-indicator');
        
        const startQuizBtn = document.getElementById('start-quiz-btn');
        const viewHistoryBtn = document.getElementById('view-history-btn');
        const exitBtn = document.getElementById('exit-btn');
        const updateBtn = document.getElementById('update-btn');
        
        const quizContainer = document.getElementById('quiz-container');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const submitBtn = document.getElementById('submit-btn');
        const backHomeBtn = document.getElementById('back-home-btn');
        
        const restartBtn = document.getElementById('restart-btn');
        const resultBackHomeBtn = document.getElementById('result-back-home-btn');
        
        const historyBackHomeBtn = document.getElementById('history-back-home-btn');
        const clearHistoryBtn = document.getElementById('clear-history-btn');
        
        const progressElement = document.getElementById('progress');
        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');
        const resultElement = document.getElementById('result');
        const historyListElement = document.getElementById('history-list');

        // ========== æ ¸å¿ƒåŠŸèƒ½å‡½æ•¸ ==========

        function startQuiz() {
            console.log('é–‹å§‹æ¸¬é©—ï¼Œæ¨¡å¼:', isVocabMode ? 'å–®å­—æ¸¬é©—' : (isPastQuestions ? 'æ­·å±†è€ƒé¡Œ' : 'æ¨¡æ“¬N4è€ƒé¡Œ'));
            
            // é‡ç½®ç‹€æ…‹
            currentQuestionIndex = 0;
            userAnswers = [];
            isAnswered = [];
            score = 0;
            wrongQuestions = [];
            selectedQuestions = [];
            shuffledQuestions = [];
            elapsedTime = 0;

            // é¸æ“‡é¡Œåº«
            let sourceBank;
            if (isVocabMode) {
                sourceBank = vocabBank;
            } else if (isPastQuestions) {
                sourceBank = pastQuestionBank;
            } else {
                sourceBank = questionBank;
            }

            // æª¢æŸ¥é¡Œåº«æ˜¯å¦å¯ç”¨
            if (!sourceBank || sourceBank.length === 0) {
                alert('é¡Œåº«è¼‰å…¥å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦');
                return;
            }

            const availableQuestions = sourceBank.length;
            const actualQuestionCount = Math.min(questionCount, availableQuestions);
            
            console.log(`å¯ç”¨é¡Œç›®: ${availableQuestions}, é¸æ“‡é¡Œæ•¸: ${actualQuestionCount}`);

            // éš¨æ©Ÿé¸æ“‡é¡Œç›®ï¼Œç¢ºä¿é¡Œå‹å¹³å‡åˆ†å¸ƒ
            selectedQuestions = selectQuestionsWithBalancedTypes(sourceBank, actualQuestionCount);
            
            // æª¢æŸ¥é¸æ“‡çš„é¡Œç›®æ˜¯å¦æœ‰æ•ˆ
            selectedQuestions = selectedQuestions.filter(question => isValidQuestion(question));
            
            if (selectedQuestions.length === 0) {
                alert('æ²’æœ‰æœ‰æ•ˆçš„é¡Œç›®å¯ç”¨ï¼Œè«‹æª¢æŸ¥é¡Œåº«æ ¼å¼');
                return;
            }
            
            // éš¨æ©Ÿæ‰“äº‚æ¯å€‹é¡Œç›®çš„é¸é …é †åº
            shuffledQuestions = selectedQuestions.map(question => shuffleOptions(question));
            
            userAnswers = new Array(selectedQuestions.length).fill(null);
            isAnswered = new Array(selectedQuestions.length).fill(false);
            
            console.log('æœ€çµ‚é¸æ“‡é¡Œç›®æ•¸é‡:', selectedQuestions.length);
            
            // é–‹å§‹è¨ˆæ™‚
            startTimer();
            
            // é¡¯ç¤ºæ¸¬é©—é é¢
            showScreen(quizScreen);
            displayQuestion(currentQuestionIndex);
            updateButtons();
            updateProgress();
        }

        // æª¢æŸ¥é¡Œç›®æ˜¯å¦æœ‰æ•ˆ
        function isValidQuestion(question) {
            if (!question) return false;
            if (!question.id) return false;
            if (!question.type) return false;
            if (!question.question) return false;
            if (!question.options || !Array.isArray(question.options) || question.options.length === 0) return false;
            if (typeof question.correctAnswer !== 'number' || question.correctAnswer < 0 || question.correctAnswer >= question.options.length) return false;
            
            // æª¢æŸ¥æ¯å€‹é¸é …æ˜¯å¦æœ‰å¿…è¦çš„å±¬æ€§
            for (let option of question.options) {
                if (!option.text) return false;
                if (!option.explanation) return false;
            }
            
            return true;
        }

        // é¸æ“‡é¡Œç›®ä¸¦ç¢ºä¿é¡Œå‹å¹³å‡åˆ†å¸ƒ
        function selectQuestionsWithBalancedTypes(sourceBank, count) {
            // å…ˆéæ¿¾æ‰ç„¡æ•ˆçš„é¡Œç›®
            const validQuestions = sourceBank.filter(question => isValidQuestion(question));
            
            if (validQuestions.length === 0) {
                console.error('é¡Œåº«ä¸­æ²’æœ‰æœ‰æ•ˆçš„é¡Œç›®');
                return [];
            }
            
            // æŒ‰é¡Œå‹åˆ†çµ„
            const questionsByType = {};
            validQuestions.forEach(question => {
                if (!questionsByType[question.type]) {
                    questionsByType[question.type] = [];
                }
                questionsByType[question.type].push(question);
            });
            
            // è¨ˆç®—æ¯ç¨®é¡Œå‹æ‡‰è©²é¸æ“‡çš„é¡Œç›®æ•¸é‡
            const types = Object.keys(questionsByType);
            const questionsPerType = Math.ceil(count / types.length);
            
            let selectedQuestions = [];
            
            // å¾æ¯ç¨®é¡Œå‹ä¸­é¸æ“‡é¡Œç›®
            types.forEach(type => {
                const availableQuestions = questionsByType[type];
                const shuffled = shuffleArray([...availableQuestions]);
                const selected = shuffled.slice(0, Math.min(questionsPerType, availableQuestions.length));
                selectedQuestions = selectedQuestions.concat(selected);
            });
            
            // å¦‚æœé¸æ“‡çš„é¡Œç›®å¤šæ–¼æ‰€éœ€ï¼Œéš¨æ©Ÿç§»é™¤å¤šé¤˜çš„é¡Œç›®
            if (selectedQuestions.length > count) {
                selectedQuestions = shuffleArray(selectedQuestions).slice(0, count);
            }
            
            // å¦‚æœé¸æ“‡çš„é¡Œç›®å°‘æ–¼æ‰€éœ€ï¼Œå¾æ‰€æœ‰é¡Œç›®ä¸­éš¨æ©Ÿè£œå……
            if (selectedQuestions.length < count) {
                const remainingCount = count - selectedQuestions.length;
                const allQuestions = shuffleArray([...validQuestions]);
                const additionalQuestions = allQuestions.filter(q => !selectedQuestions.includes(q)).slice(0, remainingCount);
                selectedQuestions = selectedQuestions.concat(additionalQuestions);
            }
            
            // æœ€å¾Œå†éš¨æ©Ÿæ‰“äº‚ä¸€æ¬¡
            return shuffleArray(selectedQuestions);
        }

        function setQuestionType(type) {
            if (type === 'past') {
                isPastQuestions = true;
                isVocabMode = false;
                updateCountButtonStates('past');
                showUpdateNotification(`æ­·å±†è€ƒé¡Œæ¨¡å¼`);
            } else if (type === 'vocab') {
                isPastQuestions = false;
                isVocabMode = true;
                updateCountButtonStates('vocab');
                showUpdateNotification(`å–®å­—æ¸¬é©—æ¨¡å¼`);
            } else {
                isPastQuestions = false;
                isVocabMode = false;
                updateCountButtonStates('simulate');
                showUpdateNotification(`æ¨¡æ“¬N4è€ƒé¡Œæ¨¡å¼`);
            }
            
            // æ ¹æ“šé¡Œåº«é¡å‹è¨­ç½®æœ€å¤§é¡Œæ•¸
            let maxQuestions = 0;
            if (isVocabMode) {
                maxQuestions = vocabBank.length;
            } else if (isPastQuestions) {
                maxQuestions = pastQuestionBank.length;
            } else {
                maxQuestions = questionBank.length;
            }
            
            questionCountInput.max = maxQuestions;
            questionCountInput.placeholder = `æœ€å¤šå¯é¸ ${maxQuestions} é¡Œ`;
            
            if (questionCountInput.value > maxQuestions) {
                questionCountInput.value = maxQuestions;
            }
        }

        function updateCountButtonStates(selectedType) {
            countSimulateBtn.classList.remove('active');
            countPastBtn.classList.remove('active');
            countVocabBtn.classList.remove('active');
            
            switch(selectedType) {
                case 'simulate':
                    countSimulateBtn.classList.add('active');
                    break;
                case 'past':
                    countPastBtn.classList.add('active');
                    break;
                case 'vocab':
                    countVocabBtn.classList.add('active');
                    break;
            }
        }

        // ========== äº‹ä»¶ç›£è½å™¨ ==========

        function initEventListeners() {
            startQuizBtn.addEventListener('click', () => {
                // å¾è¼¸å…¥æ¡†ç²å–é¡Œç›®æ•¸é‡
                questionCount = parseInt(questionCountInput.value) || 30;
                
                // æª¢æŸ¥é¡Œç›®æ•¸é‡æ˜¯å¦æœ‰æ•ˆ
                let maxQuestions = 0;
                if (isVocabMode) {
                    maxQuestions = vocabBank.length;
                } else if (isPastQuestions) {
                    maxQuestions = pastQuestionBank.length;
                } else {
                    maxQuestions = questionBank.length;
                }
                
                if (questionCount < 1) {
                    alert('é¡Œç›®æ•¸é‡å¿…é ˆå¤§æ–¼0');
                    return;
                }
                
                if (questionCount > maxQuestions) {
                    alert(`é¡Œç›®æ•¸é‡ä¸èƒ½è¶…éé¡Œåº«ç¸½æ•¸ (${maxQuestions})`);
                    questionCountInput.value = maxQuestions;
                    questionCount = maxQuestions;
                }
                
                startQuiz();
            });
            
            viewHistoryBtn.addEventListener('click', showHistory);
            exitBtn.addEventListener('click', exitApp);
            updateBtn.addEventListener('click', checkForUpdates);
            
            countSimulateBtn.addEventListener('click', () => setQuestionType('simulate'));
            countPastBtn.addEventListener('click', () => setQuestionType('past'));
            countVocabBtn.addEventListener('click', () => setQuestionType('vocab'));
            
            prevBtn.addEventListener('click', prevQuestion);
            nextBtn.addEventListener('click', nextQuestion);
            submitBtn.addEventListener('click', submitQuiz);
            backHomeBtn.addEventListener('click', backToHome);
            
            restartBtn.addEventListener('click', restartQuiz);
            resultBackHomeBtn.addEventListener('click', backToHome);
            
            historyBackHomeBtn.addEventListener('click', backToHome);
            clearHistoryBtn.addEventListener('click', clearHistory);
        }

        // ========== æ¸¬é©—æµç¨‹å‡½æ•¸ ==========

        function displayQuestion(index) {
            const question = shuffledQuestions[index];
            
            // æª¢æŸ¥é¡Œç›®æ˜¯å¦æœ‰æ•ˆ
            if (!isValidQuestion(question)) {
                quizContainer.innerHTML = `
                    <div class="error-message">
                        é¡Œç›®è³‡æ–™æ ¼å¼éŒ¯èª¤ï¼Œç„¡æ³•é¡¯ç¤ºæ­¤é¡Œç›®ã€‚
                    </div>
                `;
                return;
            }
            
            let questionHTML = '';
            
            switch(question.type) {
                case "reading":
                    questionHTML = generateReadingQuestion(question, index);
                    break;
                case "writing":
                    questionHTML = generateWritingQuestion(question, index);
                    break;
                case "vocabulary":
                    questionHTML = generateVocabularyQuestion(question, index);
                    break;
                case "synonym":
                    questionHTML = generateSynonymQuestion(question, index);
                    break;
                case "grammar":
                    questionHTML = generateGrammarQuestion(question, index);
                    break;
                default:
                    questionHTML = generateDefaultQuestion(question, index);
            }
            
            const explanationClass = isAnswered[index] ? 'explanation show' : 'explanation';
            const correctAnswerExplanation = question.options[question.correctAnswer]?.explanation || 'æ­¤é¡Œç›®æ²’æœ‰æä¾›è§£èªª';
            
            questionHTML += `
                <div class="${explanationClass}">
                    <div class="explanation-title">è§£èªªï¼š</div>
                    ${isAnswered[index] ? generateOptionExplanations(question) : correctAnswerExplanation}
                </div>
            `;
            
            quizContainer.innerHTML = questionHTML;
        }

        function generateReadingQuestion(question, index) {
            const kanjiContent = question.kanji ? `<div class="kanji">${question.kanji}</div>` : '';
            return generateQuestionHTML(question, index, kanjiContent);
        }

        function generateWritingQuestion(question, index) {
            const kanaContent = question.kana ? `<div class="kanji">${question.kana}</div>` : '';
            return generateQuestionHTML(question, index, kanaContent);
        }

        function generateVocabularyQuestion(question, index) {
            const sentenceContent = question.sentence ? `<div class="question-text">${question.sentence}</div>` : '';
            return generateQuestionHTML(question, index, sentenceContent);
        }

        function generateSynonymQuestion(question, index) {
            const sentenceContent = question.sentence ? `<div class="question-text">${question.sentence}</div>` : '';
            return generateQuestionHTML(question, index, sentenceContent);
        }

        function generateGrammarQuestion(question, index) {
            const sentenceContent = question.sentence ? `<div class="question-text">${question.sentence}</div>` : '';
            return generateQuestionHTML(question, index, sentenceContent);
        }

        function generateDefaultQuestion(question, index) {
            return generateQuestionHTML(question, index, '');
        }

        function generateQuestionHTML(question, index, extraContent) {
            let optionsHTML = '';
            const yearInfo = question.year && question.season ? 
                `<div style="font-size: 14px; color: #666; margin-bottom: 10px;">${question.year}å¹´ ${question.season}è€ƒé¡Œ</div>` : '';
            
            question.options.forEach((option, i) => {
                const isSelected = userAnswers[index] === i;
                const isCorrect = isAnswered[index] && i === question.correctAnswer;
                const isIncorrect = isAnswered[index] && isSelected && i !== question.correctAnswer;
                
                let optionClass = 'option';
                if (isSelected) optionClass += ' selected';
                if (isCorrect) optionClass += ' correct';
                if (isIncorrect) optionClass += ' incorrect';
                
                const optionText = option.text || 'é¸é …å…§å®¹ç¼ºå¤±';
                
                optionsHTML += `
                    <div class="${optionClass}" onclick="selectOption(${i})">
                        ${optionText}
                    </div>
                `;
            });
            
            return `
                <div class="question">
                    <div class="question-number">å•é¡Œ ${index + 1}</div>
                    ${yearInfo}
                    <div class="question-text">${question.question || 'é¡Œç›®å…§å®¹ç¼ºå¤±'}</div>
                    ${extraContent}
                    <div class="options">
                        ${optionsHTML}
                    </div>
                </div>
            `;
        }

        function generateOptionExplanations(question) {
            let explanationsHTML = '';
            
            question.options.forEach((option, i) => {
                const isCorrect = i === question.correctAnswer;
                const isSelected = userAnswers[currentQuestionIndex] === i;
                
                const optionText = option.text || 'é¸é …å…§å®¹ç¼ºå¤±';
                const explanationText = option.explanation || 'æ­¤é¸é …æ²’æœ‰æä¾›è§£èªª';
                
                explanationsHTML += `
                    <div class="option-explanation" style="${isCorrect ? 'border-left: 4px solid #28a745;' : isSelected ? 'border-left: 4px solid #dc3545;' : ''}">
                        <strong>é¸é … ${i+1}: ${optionText}</strong><br>
                        ${explanationText}
                    </div>
                `;
            });
            
            return explanationsHTML;
        }

        function selectOption(optionIndex) {
            if (isAnswered[currentQuestionIndex]) return;
            
            userAnswers[currentQuestionIndex] = optionIndex;
            isAnswered[currentQuestionIndex] = true;
            
            const question = shuffledQuestions[currentQuestionIndex];
            if (optionIndex === question.correctAnswer) {
                score++;
            } else {
                if (!wrongQuestions.includes(question.id)) {
                    wrongQuestions.push(question.id);
                }
            }
            
            updateScore();
            displayQuestion(currentQuestionIndex);
            updateButtons();
        }

        function updateButtons() {
            prevBtn.disabled = currentQuestionIndex === 0;
            
            if (currentQuestionIndex === shuffledQuestions.length - 1) {
                nextBtn.style.display = 'none';
                submitBtn.style.display = 'inline-block';
            } else {
                nextBtn.style.display = 'inline-block';
                submitBtn.style.display = 'none';
            }
        }

        function updateProgress() {
            progressElement.textContent = `ç¬¬ ${currentQuestionIndex + 1} é¡Œ / å…± ${shuffledQuestions.length} é¡Œ`;
        }

        function updateScore() {
            const answeredCount = isAnswered.filter(Boolean).length;
            scoreElement.textContent = `å¾—åˆ†: ${score}/${answeredCount}`;
        }

        function nextQuestion() {
            if (currentQuestionIndex < shuffledQuestions.length - 1) {
                currentQuestionIndex++;
                displayQuestion(currentQuestionIndex);
                updateButtons();
                updateProgress();
            }
        }

        function prevQuestion() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                displayQuestion(currentQuestionIndex);
                updateButtons();
                updateProgress();
            }
        }

        function submitQuiz() {
            stopTimer();
            saveHistory();
            showResults();
            showScreen(resultScreen);
        }

        function showResults() {
            const errorTypes = {
                reading: 0,
                writing: 0,
                vocabulary: 0,
                synonym: 0,
                grammar: 0
            };
            
            wrongQuestions.forEach(questionId => {
                let question = questionBank.find(q => q.id === questionId) || 
                              pastQuestionBank.find(q => q.id === questionId) ||
                              vocabBank.find(q => q.id === questionId);
                if (question && errorTypes.hasOwnProperty(question.type)) {
                    errorTypes[question.type]++;
                }
            });
            
            let resultHTML = `
                <div class="result-title">æ¸¬é©—å®Œæˆï¼</div>
                <div>æœ€çµ‚å¾—åˆ†: ${score}/${shuffledQuestions.length}</div>
                <div>ç”¨æ™‚: ${formatTime(elapsedTime)}</div>
                <div class="wrong-questions">
                    <div class="wrong-title">å„é¡Œå‹éŒ¯èª¤åˆ†æï¼š</div>
                    <ul>
                        <li>æ¼¢å­—è®€éŸ³éŒ¯èª¤: ${errorTypes.reading}</li>
                        <li>æ¼¢å­—æ›¸å¯«éŒ¯èª¤: ${errorTypes.writing}</li>
                        <li>è©èªå¡«ç©ºéŒ¯èª¤: ${errorTypes.vocabulary}</li>
                        <li>è¿‘ç¾©è©æ›¿æ›éŒ¯èª¤: ${errorTypes.synonym}</li>
                        <li>æ–‡æ³•é¸æ“‡éŒ¯èª¤: ${errorTypes.grammar}</li>
                    </ul>
                </div>
            `;
            
            if (wrongQuestions.length > 0) {
                resultHTML += `
                    <div class="wrong-questions">
                        <div class="wrong-title">éŒ¯èª¤é¡Œç›®:</div>
                        <ul>
                `;
                
                wrongQuestions.forEach(questionId => {
                    let originalQuestion = questionBank.find(q => q.id === questionId) || 
                                         pastQuestionBank.find(q => q.id === questionId) ||
                                         vocabBank.find(q => q.id === questionId);
                    
                    const shuffledQuestion = shuffledQuestions.find(q => q.id === questionId);
                    const userAnswerIndex = userAnswers[shuffledQuestions.indexOf(shuffledQuestion)];
                    
                    if (originalQuestion && shuffledQuestion) {
                        let questionText = '';
                        if (originalQuestion.type === "reading") {
                            questionText = `${originalQuestion.kanji || 'é¡Œç›®å…§å®¹ç¼ºå¤±'} - æ‚¨çš„ç­”æ¡ˆ: ${shuffledQuestion.options[userAnswerIndex]?.text || 'ç­”æ¡ˆç¼ºå¤±'} - æ­£ç¢ºç­”æ¡ˆ: ${shuffledQuestion.options[shuffledQuestion.correctAnswer]?.text || 'ç­”æ¡ˆç¼ºå¤±'}`;
                        } else if (originalQuestion.type === "writing") {
                            questionText = `${originalQuestion.kana || 'é¡Œç›®å…§å®¹ç¼ºå¤±'} - æ‚¨çš„ç­”æ¡ˆ: ${shuffledQuestion.options[userAnswerIndex]?.text || 'ç­”æ¡ˆç¼ºå¤±'} - æ­£ç¢ºç­”æ¡ˆ: ${shuffledQuestion.options[shuffledQuestion.correctAnswer]?.text || 'ç­”æ¡ˆç¼ºå¤±'}`;
                        } else {
                            questionText = `å•é¡Œ ${originalQuestion.id} - æ‚¨çš„ç­”æ¡ˆ: ${shuffledQuestion.options[userAnswerIndex]?.text || 'ç­”æ¡ˆç¼ºå¤±'} - æ­£ç¢ºç­”æ¡ˆ: ${shuffledQuestion.options[shuffledQuestion.correctAnswer]?.text || 'ç­”æ¡ˆç¼ºå¤±'}`;
                        }
                        
                        resultHTML += `<li>${questionText}</li>`;
                    }
                });
                
                resultHTML += `
                        </ul>
                    </div>
                `;
            } else {
                resultHTML += `<div class="success-message">æ­å–œï¼å…¨éƒ¨ç­”å°ï¼</div>`;
            }
            
            resultElement.innerHTML = resultHTML;
        }

        // ========== å·¥å…·å‡½æ•¸ ==========

        function startTimer() {
            startTime = new Date();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            const now = new Date();
            elapsedTime = Math.floor((now - startTime) / 1000);
            
            const minutes = Math.floor(elapsedTime / 60);
            const seconds = elapsedTime % 60;
            
            timerElement.textContent = `æ™‚é–“: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function shuffleOptions(question) {
            const optionsWithIndex = question.options.map((option, index) => ({...option, originalIndex: index}));
            const shuffledOptions = shuffleArray(optionsWithIndex);
            
            const newCorrectAnswerIndex = shuffledOptions.findIndex(option => option.originalIndex === question.correctAnswer);
            
            return {
                ...question,
                options: shuffledOptions.map(option => ({text: option.text, explanation: option.explanation})),
                correctAnswer: newCorrectAnswerIndex
            };
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function showScreen(screen) {
            homeScreen.classList.remove('active');
            quizScreen.classList.remove('active');
            resultScreen.classList.remove('active');
            historyScreen.classList.remove('active');
            
            screen.classList.add('active');
        }

        function backToHome() {
            stopTimer();
            showScreen(homeScreen);
        }

        function restartQuiz() {
            backToHome();
            setTimeout(() => startQuiz(), 100);
        }

        function showHistory() {
            historyListElement.innerHTML = '';
            
            if (history.length === 0) {
                historyListElement.innerHTML = '<p>å°šç„¡æ¸¬é©—ç´€éŒ„</p>';
            } else {
                history.forEach((record, index) => {
                    const historyItem = document.createElement('div');
                    historyItem.className = 'history-item';
                    
                    const date = new Date(record.date);
                    const formattedDate = `${date.getFullYear()}/${(date.getMonth()+1).toString().padStart(2, '0')}/${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
                    
                    historyItem.innerHTML = `
                        <div class="history-date">${formattedDate} - ${record.mode}</div>
                        <div class="history-stats">
                            <div class="history-stat">å¾—åˆ†: ${record.score}/${record.total}</div>
                            <div class="history-stat">æ­£ç¢ºç‡: ${Math.round((record.score / record.total) * 100)}%</div>
                            <div class="history-stat">ç”¨æ™‚: ${record.time}</div>
                        </div>
                    `;
                    
                    historyListElement.appendChild(historyItem);
                });
            }
            
            showScreen(historyScreen);
        }

        function saveHistory() {
            const record = {
                date: new Date().toISOString(),
                score: score,
                total: shuffledQuestions.length,
                time: formatTime(elapsedTime),
                mode: isVocabMode ? 'å–®å­—æ¸¬é©—' : (isPastQuestions ? 'æ­·å±†è€ƒé¡Œ' : 'æ¨¡æ“¬N4è€ƒé¡Œ')
            };
            
            history.unshift(record);
            
            if (history.length > 50) {
                history = history.slice(0, 50);
            }
            
            localStorage.setItem('n4QuizHistory', JSON.stringify(history));
        }

        function clearHistory() {
            if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰æ¸¬é©—ç´€éŒ„å—ï¼Ÿ')) {
                history = [];
                localStorage.removeItem('n4QuizHistory');
                showHistory();
            }
        }

        function exitApp() {
            if (confirm('ç¢ºå®šè¦çµæŸæ¸¬é©—å—ï¼Ÿ')) {
                // å¦‚æœæ˜¯PWAï¼Œé—œé–‰æ‡‰ç”¨
                if (window.navigator.standalone) {
                    window.close();
                } else {
                    alert('æ¸¬é©—å·²çµæŸï¼Œæ‚¨å¯ä»¥é—œé–‰æ­¤é é¢');
                }
            }
        }

        function showUpdateNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'success-message';
            notification.textContent = message;
            notification.style.position = 'fixed';
            notification.style.top = '20px';
            notification.style.left = '50%';
            notification.style.transform = 'translateX(-50%)';
            notification.style.zIndex = '1000';
            notification.style.maxWidth = '80%';
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 2000);
        }

        // ========== é¡Œåº«è¼‰å…¥èˆ‡æ›´æ–° ==========

        function loadQuestionBanks() {
            // å˜—è©¦å¾å¤–éƒ¨JSæ–‡ä»¶è¼‰å…¥é¡Œåº«
            const scriptTags = document.querySelectorAll('script[src]');
            let questionBankLoaded = false;
            let pastQuestionBankLoaded = false;
            let vocabBankLoaded = false;
            
            // æª¢æŸ¥æ˜¯å¦å·²ç¶“è¼‰å…¥äº†å¤–éƒ¨é¡Œåº«
            scriptTags.forEach(script => {
                if (script.src.includes('question_bank.js')) questionBankLoaded = true;
                if (script.src.includes('pastQuestionBank.js')) pastQuestionBankLoaded = true;
                if (script.src.includes('vocab_bank.js')) vocabBankLoaded = true;
            });
            
            // å¦‚æœæ²’æœ‰è¼‰å…¥å¤–éƒ¨é¡Œåº«ï¼Œå˜—è©¦å‹•æ…‹è¼‰å…¥
            if (!questionBankLoaded) {
                loadScript('question_bank.js', () => {
                    if (typeof window.questionBank !== 'undefined') {
                        questionBank = window.questionBank;
                        console.log('æ¨¡æ“¬N4è€ƒé¡Œé¡Œåº«è¼‰å…¥æˆåŠŸï¼Œé¡Œç›®æ•¸é‡:', questionBank.length);
                    } else {
                        console.error('ç„¡æ³•è¼‰å…¥æ¨¡æ“¬N4è€ƒé¡Œé¡Œåº«');
                    }
                });
            } else {
                // å¦‚æœå·²ç¶“è¼‰å…¥ï¼Œç›´æ¥ä½¿ç”¨å…¨åŸŸè®Šæ•¸
                if (typeof window.questionBank !== 'undefined') {
                    questionBank = window.questionBank;
                    console.log('æ¨¡æ“¬N4è€ƒé¡Œé¡Œåº«è¼‰å…¥æˆåŠŸï¼Œé¡Œç›®æ•¸é‡:', questionBank.length);
                }
            }
            
            if (!pastQuestionBankLoaded) {
                loadScript('pastQuestionBank.js', () => {
                    if (typeof window.pastQuestionBank !== 'undefined') {
                        pastQuestionBank = window.pastQuestionBank;
                        console.log('æ­·å±†è€ƒé¡Œé¡Œåº«è¼‰å…¥æˆåŠŸï¼Œé¡Œç›®æ•¸é‡:', pastQuestionBank.length);
                    } else {
                        console.error('ç„¡æ³•è¼‰å…¥æ­·å±†è€ƒé¡Œé¡Œåº«');
                    }
                });
            } else {
                if (typeof window.pastQuestionBank !== 'undefined') {
                    pastQuestionBank = window.pastQuestionBank;
                    console.log('æ­·å±†è€ƒé¡Œé¡Œåº«è¼‰å…¥æˆåŠŸï¼Œé¡Œç›®æ•¸é‡:', pastQuestionBank.length);
                }
            }
            
            if (!vocabBankLoaded) {
                loadScript('vocab_bank.js', () => {
                    if (typeof window.vocabBank !== 'undefined') {
                        vocabBank = window.vocabBank;
                        console.log('å–®å­—æ¸¬é©—é¡Œåº«è¼‰å…¥æˆåŠŸï¼Œé¡Œç›®æ•¸é‡:', vocabBank.length);
                    } else {
                        console.error('ç„¡æ³•è¼‰å…¥å–®å­—æ¸¬é©—é¡Œåº«');
                    }
                });
            } else {
                if (typeof window.vocabBank !== 'undefined') {
                    vocabBank = window.vocabBank;
                    console.log('å–®å­—æ¸¬é©—é¡Œåº«è¼‰å…¥æˆåŠŸï¼Œé¡Œç›®æ•¸é‡:', vocabBank.length);
                }
            }
            
            // æª¢æŸ¥æ˜¯å¦æœ‰é¡Œåº«è¼‰å…¥å¤±æ•—
            setTimeout(() => {
                if (questionBank.length === 0 || pastQuestionBank.length === 0 || vocabBank.length === 0) {
                    console.warn('éƒ¨åˆ†é¡Œåº«è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥é¡Œåº«æ–‡ä»¶æ˜¯å¦å­˜åœ¨');
                }
            }, 1000);
        }

        function loadScript(src, callback) {
            const script = document.createElement('script');
            script.src = src;
            script.onload = callback;
            script.onerror = () => {
                console.error(`è¼‰å…¥é¡Œåº«å¤±æ•—: ${src}`);
                callback();
            };
            document.head.appendChild(script);
        }

        function checkForUpdates() {
            // æ¨¡æ“¬æª¢æŸ¥æ›´æ–°
            const lastUpdate = localStorage.getItem('lastUpdateCheck');
            const now = new Date().getTime();
            
            if (lastUpdate && (now - parseInt(lastUpdate)) < 60000) {
                showUpdateNotification('å·²æ˜¯æœ€æ–°ç‰ˆæœ¬');
                return;
            }
            
            showUpdateNotification('æª¢æŸ¥æ›´æ–°ä¸­...');
            
            // æ¨¡æ“¬æ›´æ–°éç¨‹
            setTimeout(() => {
                localStorage.setItem('lastUpdateCheck', now.toString());
                showUpdateNotification('å·²æ˜¯æœ€æ–°ç‰ˆæœ¬');
            }, 1500);
        }

        // ========== åˆå§‹åŒ–æ‡‰ç”¨ ==========

        function initApp() {
            console.log('åˆå§‹åŒ–æ¸¬é©—ç³»çµ±...');
            
            // è¼‰å…¥é¡Œåº«
            loadQuestionBanks();
            
            // åˆå§‹åŒ–äº‹ä»¶ç›£è½å™¨
            initEventListeners();
            
            // è¨­ç½®é è¨­æ¸¬é©—é¡å‹
            setQuestionType('simulate');
            
            console.log('æ¸¬é©—ç³»çµ±åˆå§‹åŒ–å®Œæˆ');
        }

        // ç•¶é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–æ‡‰ç”¨
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>