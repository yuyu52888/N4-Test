<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#3498db">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="æ—¥æ–‡N4æ¸¬é©—">

    <!-- Icons -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ“š</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ“š</text></svg>">
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥æ–‡N4å–®å­—èˆ‡æ–‡æ³•æ¸¬é©—ç³»çµ±</title>
    <style>
    * {
        box-sizing: border-box;
        font-family: "Microsoft JhengHei", "Segoe UI", sans-serif;
    }
    body {
        background-color: #f5f5f5;
        margin: 0;
        padding: 20px;
        color: #333;
        line-height: 1.6;
    }
    .container {
        max-width: 800px;
        margin: 0 auto;
        background: white;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        padding: 25px;
        position: relative;
    }
    h1 {
        color: #2c3e50;
        text-align: center;
        margin-bottom: 30px;
        border-bottom: 2px solid #eee;
        padding-bottom: 15px;
    }
    .home-screen, .quiz-screen, .result-screen, .history-screen {
        display: none;
    }
    .home-screen.active, .quiz-screen.active, .result-screen.active, .history-screen.active {
        display: block;
    }
    .home-buttons {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-top: 30px;
    }
    .home-btn {
        padding: 15px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 18px;
        transition: background-color 0.3s;
    }
    .home-btn:hover {
        background-color: #2980b9;
    }
    .home-btn.exit {
        background-color: #e74c3c;
    }
    .home-btn.exit:hover {
        background-color: #c0392b;
    }
    .home-btn.update {
        background-color: #2ecc71;
    }
    .home-btn.update:hover {
        background-color: #27ae60;
    }
    
    /* æ¸¬é©—é¡å‹é¸æ“‡æŒ‰éˆ•æ¨£å¼ */
    .count-buttons-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-top: 15px;
    }
    .count-btn {
        margin: 0;
        padding: 15px 10px;
        background-color: #95a5a6;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s ease;
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
    }
    .count-btn.active {
        background-color: #2ecc71;
        font-weight: bold;
        transform: scale(1.02);
        box-shadow: 0 4px 8px rgba(46, 204, 113, 0.3);
    }
    .count-btn:hover {
        background-color: #7f8c8d;
        transform: translateY(-2px);
    }
    .count-btn.active:hover {
        background-color: #27ae60;
    }
    
    .question {
        margin-bottom: 25px;
        padding: 15px;
        border-radius: 8px;
        background-color: #f9f9f9;
    }
    .question-number {
        font-weight: bold;
        color: #3498db;
        margin-bottom: 10px;
    }
    .question-text {
        font-size: 18px;
        margin-bottom: 15px;
        line-height: 1.5;
    }
    .kanji {
        font-size: 24px;
        font-weight: bold;
        color: #e74c3c;
        margin: 10px 0;
        text-align: center;
    }
    .options {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    .option {
        padding: 12px 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.2s;
    }
    .option:hover {
        background-color: #f0f0f0;
    }
    .option.selected {
        background-color: #d6eaf8;
        border-color: #3498db;
    }
    .option.correct {
        background-color: #d4edda;
        border-color: #28a745;
    }
    .option.incorrect {
        background-color: #f8d7da;
        border-color: #dc3545;
    }
    .explanation {
        margin-top: 15px;
        padding: 15px;
        background-color: #e8f4fc;
        border-radius: 5px;
        display: none;
    }
    .explanation.show {
        display: block;
    }
    .explanation-title {
        font-weight: bold;
        color: #2c3e50;
        margin-bottom: 8px;
    }
    .option-explanation {
        margin-top: 10px;
        padding: 8px;
        background-color: #f8f9fa;
        border-radius: 4px;
        font-size: 14px;
    }
    .button-container {
        display: flex;
        justify-content: center;
        margin-top: 30px;
        gap: 15px;
        flex-wrap: wrap;
    }
    button {
        padding: 12px 25px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s;
    }
    button:hover {
        background-color: #2980b9;
    }
    button:disabled {
        background-color: #bdc3c7;
        cursor: not-allowed;
    }
    button.restart {
        background-color: #e67e22;
    }
    button.restart:hover {
        background-color: #d35400;
    }
    .stats {
        text-align: center;
        margin-bottom: 20px;
        font-size: 18px;
        color: #2c3e50;
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
    }
    .timer {
        font-weight: bold;
        color: #e74c3c;
    }
    .result {
        text-align: center;
        margin-top: 20px;
        padding: 15px;
        border-radius: 8px;
        background-color: #e8f4fc;
    }
    .result-title {
        font-weight: bold;
        font-size: 20px;
        margin-bottom: 10px;
        color: #2c3e50;
    }
    .wrong-questions {
        margin-top: 20px;
        text-align: left;
    }
    .wrong-title {
        font-weight: bold;
        margin-bottom: 10px;
        color: #e74c3c;
    }
    .history-list {
        margin-top: 20px;
    }
    .history-item {
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        margin-bottom: 10px;
        background-color: #f9f9f9;
    }
    .history-date {
        font-weight: bold;
        color: #2c3e50;
    }
    .history-stats {
        display: flex;
        justify-content: space-between;
        margin-top: 10px;
        flex-wrap: wrap;
    }
    .history-stat {
        flex: 1;
        min-width: 120px;
        text-align: center;
        padding: 5px;
    }
    .question-count-selector {
        margin: 20px 0;
        text-align: center;
    }
    .loading {
        opacity: 0.6;
        pointer-events: none;
    }
    .error-message {
        background-color: #f8d7da;
        color: #721c24;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
        text-align: center;
    }
    .success-message {
        background-color: #d4edda;
        color: #155724;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
        text-align: center;
    }
    .update-indicator {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 10px;
        height: 10px;
        background-color: #2ecc71;
        border-radius: 50%;
        z-index: 1001;
        animation: pulse 2s infinite;
    }
    .update-indicator.outdated {
        background-color: #e74c3c;
    }
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
    }
    
    /* æ‰‹æ©Ÿç‰ˆæ¨£å¼ */
    @media (max-width: 768px) {
        .container {
            padding: 15px;
            margin: 10px;
            border-radius: 8px;
        }
        h1 {
            font-size: 24px;
            margin-bottom: 20px;
        }
        .home-btn, button {
            padding: 18px;
            font-size: 16px;
        }
        .question-text {
            font-size: 16px;
        }
        .kanji {
            font-size: 20px;
        }
        .option {
            padding: 15px;
            font-size: 16px;
            min-height: 44px;
            display: flex;
            align-items: center;
        }
        .button-container {
            flex-direction: column;
            gap: 10px;
        }
        .button-container button {
            width: 100%;
        }
        .history-stats {
            flex-direction: column;
        }
        .history-stat {
            min-width: 100%;
            text-align: left;
            margin-bottom: 5px;
        }
        .stats {
            flex-direction: column;
            gap: 10px;
        }
        .count-buttons-container {
            grid-template-columns: 1fr;
            gap: 10px;
        }
        .count-btn {
            padding: 18px 15px;
            font-size: 18px;
            min-height: 60px;
        }
        .question-count-selector p {
            font-size: 18px;
            margin-bottom: 15px;
        }
    }
    
    /* é˜²æ­¢æ‰‹æ©Ÿä¸Šé»æ“Šé«˜äº® */
    * {
        -webkit-tap-highlight-color: transparent;
    }
    /* æ”¹å–„è§¸æ‘¸é«”é©— */
    button, .option {
        touch-action: manipulation;
    }
    </style>
</head>
<body>
    <div class="container">
        <div class="update-indicator" id="update-indicator"></div>
        <h1>æ—¥æ–‡N4å–®å­—èˆ‡æ–‡æ³•æ¸¬é©—ç³»çµ±</h1>
        
        <!-- é¦–é  -->
        <div id="home-screen" class="home-screen active">
            <div class="home-buttons">
                <button id="start-quiz-btn" class="home-btn">é–‹å§‹æ¸¬é©—</button>
                <button id="update-btn" class="home-btn update">æª¢æŸ¥é¡Œåº«æ›´æ–°</button>
                
                <div class="question-count-selector">
                    <p>é¸æ“‡æ¸¬é©—é¡å‹èˆ‡é¡Œç›®æ•¸é‡ï¼š</p>
                    <div class="count-buttons-container">
                        <button id="count-30-btn" class="count-btn active">30é¡Œ</button>
                        <button id="count-50-btn" class="count-btn">50é¡Œ</button>
                        <button id="count-past-btn" class="count-btn">æ­·å±†è€ƒé¡Œ</button>
                        <button id="count-vocab-btn" class="count-btn">å–®å­—æ¸¬é©—</button>
                    </div>
                </div>
                
                <button id="view-history-btn" class="home-btn">æ­·å²ç´€éŒ„æŸ¥è©¢</button>
                <button id="exit-btn" class="home-btn exit">çµæŸæ¸¬é©—</button>
            </div>
        </div>
        
        <!-- æ¸¬é©—é é¢ -->
        <div id="quiz-screen" class="quiz-screen">
            <div class="stats">
                <span id="progress">ç¬¬ 1 é¡Œ / å…± 10 é¡Œ</span>
                <span id="score">å¾—åˆ†: 0/0</span>
                <span id="timer" class="timer">æ™‚é–“: 00:00</span>
            </div>
            
            <div id="quiz-container">
                <!-- é¡Œç›®å°‡ç”±JavaScriptå‹•æ…‹ç”Ÿæˆ -->
            </div>
            
            <div class="button-container">
                <button id="prev-btn" disabled>ä¸Šä¸€é¡Œ</button>
                <button id="next-btn">ä¸‹ä¸€é¡Œ</button>
                <button id="submit-btn" style="display: none;">æäº¤ç­”æ¡ˆ</button>
                <button id="back-home-btn" class="restart">è¿”å›é¦–é </button>
            </div>
        </div>
        
        <!-- çµæœé é¢ -->
        <div id="result-screen" class="result-screen">
            <div id="result" class="result">
                <!-- æ¸¬é©—çµæœå°‡åœ¨é€™è£¡é¡¯ç¤º -->
            </div>
            
            <div class="button-container">
                <button id="restart-btn" class="restart">é‡æ–°é–‹å§‹æ¸¬é©—</button>
                <button id="result-back-home-btn">è¿”å›é¦–é </button>
            </div>
        </div>
        
        <!-- æ­·å²ç´€éŒ„é é¢ -->
        <div id="history-screen" class="history-screen">
            <h2>æ¸¬é©—æ­·å²ç´€éŒ„</h2>
            
            <div id="history-list" class="history-list">
                <!-- æ­·å²ç´€éŒ„å°‡åœ¨é€™è£¡é¡¯ç¤º -->
            </div>
            
            <div class="button-container">
                <button id="history-back-home-btn">è¿”å›é¦–é </button>
                <button id="clear-history-btn" class="restart">æ¸…é™¤æ­·å²ç´€éŒ„</button>
            </div>
        </div>
    </div>

    <script>
        // æ­·å±†è€ƒé¡Œè³‡æ–™åº«
        window.pastQuestionBank = [
            {
                id: 101,
                type: "reading",
                question: "è«‹é¸æ“‡ä¸‹åˆ—æ¼¢å­—çš„æ­£ç¢ºè®€éŸ³",
                kanji: "å‹‰å¼·",
                options: [
                    { text: "ã¹ã‚“ãã‚‡ã†", explanation: "æ­£ç¢ºï¼ã€Œå‹‰å¼·ã€çš„è®€éŸ³æ˜¯ã€Œã¹ã‚“ãã‚‡ã†ã€" },
                    { text: "ã¹ã‚“ãã‚‡", explanation: "éŒ¯èª¤ï¼ç¼ºå°‘é•·éŸ³" },
                    { text: "ã¹ã‚“ãã‚…ã†", explanation: "éŒ¯èª¤ï¼é€™æ˜¯ã€Œç ”ç©¶ã€çš„è®€éŸ³" },
                    { text: "ã‚ã‚“ãã‚‡ã†", explanation: "éŒ¯èª¤ï¼è®€éŸ³ä¸æ­£ç¢º" }
                ],
                correctAnswer: 0,
                year: "2023",
                season: "å¤å­£"
            },
            {
                id: 102,
                type: "grammar",
                question: "è«‹é¸æ“‡æ­£ç¢ºçš„æ–‡æ³•å½¢å¼",
                sentence: "ã“ã®æœ¬ã¯æ˜¨æ—¥ï¼¿ï¼¿ï¼¿ï¼¿ã€‚",
                options: [
                    { text: "è²·ã„ã¾ã—ãŸ", explanation: "æ­£ç¢ºï¼è¡¨ç¤ºæ˜¨å¤©è²·äº†é€™æœ¬æ›¸" },
                    { text: "è²·ã„ã¾ã™", explanation: "éŒ¯èª¤ï¼æ‡‰è©²ä½¿ç”¨éå»å½¢" },
                    { text: "è²·ã„ã¾ã—ã‚‡ã†", explanation: "éŒ¯èª¤ï¼é€™æ˜¯å‹¸èª˜å½¢" },
                    { text: "è²·ã£ã¦ãã ã•ã„", explanation: "éŒ¯èª¤ï¼é€™æ˜¯è«‹æ±‚å½¢" }
                ],
                correctAnswer: 0,
                year: "2023",
                season: "æ˜¥å­£"
            },
            {
                id: 103,
                type: "vocabulary",
                question: "è«‹é¸æ“‡æœ€é©åˆçš„è©èªå¡«å…¥ç©ºæ ¼",
                sentence: "é›»è»ŠãŒï¼¿ï¼¿ï¼¿ï¼¿ã„ã¾ã™ã€‚",
                options: [
                    { text: "è¾¼ã‚“ã§", explanation: "æ­£ç¢ºï¼è¡¨ç¤ºé›»è»Šå¾ˆæ“æ“ " },
                    { text: "å…¥ã£ã¦", explanation: "éŒ¯èª¤ï¼ã€Œå…¥ã£ã¦ã€æ˜¯é€²å…¥çš„æ„æ€" },
                    { text: "æ¥ã¦", explanation: "éŒ¯èª¤ï¼ã€Œæ¥ã¦ã€æ˜¯ä¾†çš„æ„æ€" },
                    { text: "è¡Œã£ã¦", explanation: "éŒ¯èª¤ï¼ã€Œè¡Œã£ã¦ã€æ˜¯å»çš„æ„æ€" }
                ],
                correctAnswer: 0,
                year: "2022",
                season: "å†¬å­£"
            },
            {
                id: 104,
                type: "writing",
                question: "è«‹é¸æ“‡ä¸‹åˆ—è®€éŸ³çš„æ­£ç¢ºæ¼¢å­—",
                kana: "ã—ã‘ã‚“",
                options: [
                    { text: "è©¦é¨“", explanation: "æ­£ç¢ºï¼ã€Œã—ã‘ã‚“ã€çš„æ¼¢å­—æ˜¯ã€Œè©¦é¨“ã€" },
                    { text: "ç§è¦‹", explanation: "éŒ¯èª¤ï¼ã€Œç§è¦‹ã€æ˜¯å€‹äººæ„è¦‹çš„æ„æ€" },
                    { text: "è³‡æº", explanation: "éŒ¯èª¤ï¼ã€Œè³‡æºã€çš„è®€éŸ³æ˜¯ã€Œã—ã’ã‚“ã€" },
                    { text: "äº‹ä»¶", explanation: "éŒ¯èª¤ï¼ã€Œäº‹ä»¶ã€çš„è®€éŸ³æ˜¯ã€Œã˜ã‘ã‚“ã€" }
                ],
                correctAnswer: 0,
                year: "2022",
                season: "ç§‹å­£"
            },
            {
                id: 105,
                type: "synonym",
                question: "è«‹é¸æ“‡èˆ‡åŠƒç·šè©èªæ„æ€æœ€æ¥è¿‘çš„é¸é …",
                sentence: "å½¼ã¯ã¨ã¦ã‚‚è¦ªåˆ‡ãªäººã§ã™ã€‚",
                options: [
                    { text: "å„ªã—ã„", explanation: "æ­£ç¢ºï¼ã€Œè¦ªåˆ‡ã€å’Œã€Œå„ªã—ã„ã€æ„æ€ç›¸è¿‘" },
                    { text: "å³ã—ã„", explanation: "éŒ¯èª¤ï¼ã€Œå³ã—ã„ã€æ˜¯åš´æ ¼çš„æ„æ€" },
                    { text: "å¼·ã„", explanation: "éŒ¯èª¤ï¼ã€Œå¼·ã„ã€æ˜¯å¼·å£¯çš„æ„æ€" },
                    { text: "è³¢ã„", explanation: "éŒ¯èª¤ï¼ã€Œè³¢ã„ã€æ˜¯è°æ˜çš„æ„æ€" }
                ],
                correctAnswer: 0,
                year: "2021",
                season: "å¤å­£"
            }
        ];

        // å…§å»ºé¡Œåº«è³‡æ–™
        window.questionBank = [
            {
                id: 1,
                type: "reading",
                question: "è«‹é¸æ“‡ä¸‹åˆ—æ¼¢å­—çš„æ­£ç¢ºè®€éŸ³",
                kanji: "å­¦æ ¡",
                options: [
                    { text: "ãŒã£ã“ã†", explanation: "æ­£ç¢ºï¼ã€Œå­¦æ ¡ã€çš„è®€éŸ³æ˜¯ã€ŒãŒã£ã“ã†ã€" },
                    { text: "ãŒãã“ã†", explanation: "éŒ¯èª¤ï¼ã€Œå­¦ã€åœ¨è¤‡åˆè©ä¸­å¸¸è®€ä½œã€ŒãŒã£ã€" },
                    { text: "ãŒããã‚‡ã†", explanation: "éŒ¯èª¤ï¼é€™æ˜¯ã€Œå­¦ç¿’ã€çš„è®€éŸ³" },
                    { text: "ãŒã£ãã‚‡ã†", explanation: "éŒ¯èª¤ï¼é€™æ˜¯ã€Œæ¥½å™¨ã€ç›¸é—œçš„è®€éŸ³" }
                ],
                correctAnswer: 0
            },
            {
                id: 2,
                type: "writing",
                question: "è«‹é¸æ“‡ä¸‹åˆ—è®€éŸ³çš„æ­£ç¢ºæ¼¢å­—",
                kana: "ã¨ã‚‚ã ã¡",
                options: [
                    { text: "å‹é”", explanation: "æ­£ç¢ºï¼ã€Œã¨ã‚‚ã ã¡ã€çš„æ¼¢å­—æ˜¯ã€Œå‹é”ã€" },
                    { text: "å‹ç«‹", explanation: "éŒ¯èª¤ï¼ã€Œç«‹ã€çš„è®€éŸ³æ˜¯ã€ŒãŸã¡ã€" },
                    { text: "å…±é”", explanation: "éŒ¯èª¤ï¼ã€Œå…±ã€çš„è®€éŸ³æ˜¯ã€Œã¨ã‚‚ã€ä½†æ„æ€ä¸åŒ" },
                    { text: "çŸ¥å‹", explanation: "éŒ¯èª¤ï¼é€™æ˜¯è‡ªå‰µçš„çµ„åˆ" }
                ],
                correctAnswer: 0
            },
            {
                id: 3,
                type: "vocabulary",
                question: "è«‹é¸æ“‡æœ€é©åˆçš„è©èªå¡«å…¥ç©ºæ ¼",
                sentence: "æ˜¨æ—¥ã€æ–°ã—ã„æœ¬ã‚’ï¼¿ï¼¿ï¼¿ï¼¿ã€‚",
                options: [
                    { text: "è²·ã„ã¾ã—ãŸ", explanation: "æ­£ç¢ºï¼è¡¨ç¤ºè³¼è²·äº†æ–°çš„æ›¸" },
                    { text: "å£²ã‚Šã¾ã—ãŸ", explanation: "éŒ¯èª¤ï¼ã€Œå£²ã‚Šã¾ã—ãŸã€æ˜¯è³£å‡ºçš„æ„æ€" },
                    { text: "èª­ã¿ã¾ã—ãŸ", explanation: "éŒ¯èª¤ï¼é›–ç„¶å¯ä»¥è®€æ›¸ï¼Œä½†èˆ‡ã€Œæ–°ã—ã„æœ¬ã€çš„èªå¢ƒä¸ç¬¦" },
                    { text: "æ›¸ãã¾ã—ãŸ", explanation: "éŒ¯èª¤ï¼ã€Œæ›¸ãã¾ã—ãŸã€æ˜¯å¯«çš„æ„æ€" }
                ],
                correctAnswer: 0
            },
            {
                id: 4,
                type: "synonym",
                question: "è«‹é¸æ“‡èˆ‡åŠƒç·šè©èªæ„æ€æœ€æ¥è¿‘çš„é¸é …",
                sentence: "ã“ã®æ–™ç†ã¯ã¨ã¦ã‚‚ç¾å‘³ã—ã„ã§ã™ã€‚",
                options: [
                    { text: "ãŠã„ã—ã„", explanation: "æ­£ç¢ºï¼ã€Œç¾å‘³ã—ã„ã€å’Œã€ŒãŠã„ã—ã„ã€æ„æ€ç›¸åŒ" },
                    { text: "ã¾ãšã„", explanation: "éŒ¯èª¤ï¼ã€Œã¾ãšã„ã€æ˜¯é›£åƒçš„æ„æ€" },
                    { text: "ãã‚Œã„", explanation: "éŒ¯èª¤ï¼ã€Œãã‚Œã„ã€æ˜¯æ¼‚äº®çš„æ„æ€" },
                    { text: "ã‚ã¤ã„", explanation: "éŒ¯èª¤ï¼ã€Œã‚ã¤ã„ã€æ˜¯ç†±çš„æ„æ€" }
                ],
                correctAnswer: 0
            },
            {
                id: 5,
                type: "grammar",
                question: "è«‹é¸æ“‡æ­£ç¢ºçš„æ–‡æ³•å½¢å¼",
                sentence: "ç§ã¯æ¯æ—¥æ—¥æœ¬èªï¼¿ï¼¿ï¼¿ï¼¿å‹‰å¼·ã—ã¾ã™ã€‚",
                options: [
                    { text: "ã‚’", explanation: "æ­£ç¢ºï¼è¡¨ç¤ºå­¸ç¿’çš„å°è±¡" },
                    { text: "ãŒ", explanation: "éŒ¯èª¤ï¼ã€ŒãŒã€ç”¨æ–¼ä¸»èªæˆ–å°è±¡èª" },
                    { text: "ã«", explanation: "éŒ¯èª¤ï¼ã€Œã«ã€è¡¨ç¤ºæ™‚é–“ã€åœ°é»æˆ–ç›®çš„" },
                    { text: "ã§", explanation: "éŒ¯èª¤ï¼ã€Œã§ã€è¡¨ç¤ºæ‰‹æ®µæˆ–å ´æ‰€" }
                ],
                correctAnswer: 0
            },
            {
                id: 6,
                type: "reorder",
                question: "è«‹å°‡ä¸‹åˆ—è©èªçµ„åˆæˆæ­£ç¢ºçš„å¥å­",
                sentence: "ãƒ»å›³æ›¸é¤¨ ãƒ»ã§ ãƒ»æœ¬ ãƒ»ã‚’ ãƒ»èª­ã¿ã¾ã™",
                options: [
                    { text: "å›³æ›¸é¤¨ã§æœ¬ã‚’èª­ã¿ã¾ã™ã€‚", explanation: "æ­£ç¢ºï¼é€™æ˜¯æ¨™æº–çš„æ—¥èªèªåº" },
                    { text: "æœ¬ã‚’å›³æ›¸é¤¨ã§èª­ã¿ã¾ã™ã€‚", explanation: "éŒ¯èª¤ï¼é›–ç„¶èªæ³•æ­£ç¢ºï¼Œä½†ä¸å¦‚é¸é …1è‡ªç„¶" },
                    { text: "èª­ã¿ã¾ã™æœ¬ã‚’å›³æ›¸é¤¨ã§ã€‚", explanation: "éŒ¯èª¤ï¼å‹•è©æ‡‰è©²åœ¨å¥å°¾" },
                    { text: "å›³æ›¸é¤¨ã‚’æœ¬ã§èª­ã¿ã¾ã™ã€‚", explanation: "éŒ¯èª¤ï¼åŠ©è©ä½¿ç”¨éŒ¯èª¤" }
                ],
                correctAnswer: 0
            },
            {
                id: 7,
                type: "reading",
                question: "è«‹é¸æ“‡ä¸‹åˆ—æ¼¢å­—çš„æ­£ç¢ºè®€éŸ³",
                kanji: "å…ˆç”Ÿ",
                options: [
                    { text: "ã›ã‚“ã›ã„", explanation: "æ­£ç¢ºï¼ã€Œå…ˆç”Ÿã€çš„è®€éŸ³æ˜¯ã€Œã›ã‚“ã›ã„ã€" },
                    { text: "ã›ã‚“ã›", explanation: "éŒ¯èª¤ï¼ç¼ºå°‘é•·éŸ³" },
                    { text: "ã›ã„ã›ã‚“", explanation: "éŒ¯èª¤ï¼é€™æ˜¯ã€Œæ¸…æƒã€ç›¸é—œçš„è®€éŸ³" },
                    { text: "ã›ã‚“ã›ãˆ", explanation: "éŒ¯èª¤ï¼é•·éŸ³å½¢å¼ä¸æ­£ç¢º" }
                ],
                correctAnswer: 0
            },
            {
                id: 8,
                type: "writing",
                question: "è«‹é¸æ“‡ä¸‹åˆ—è®€éŸ³çš„æ­£ç¢ºæ¼¢å­—",
                kana: "ã«ã»ã‚“ã”",
                options: [
                    { text: "æ—¥æœ¬èª", explanation: "æ­£ç¢ºï¼ã€Œã«ã»ã‚“ã”ã€çš„æ¼¢å­—æ˜¯ã€Œæ—¥æœ¬èªã€" },
                    { text: "äºŒæœ¬èª", explanation: "éŒ¯èª¤ï¼ã€ŒäºŒæœ¬ã€æ˜¯æ•¸é‡è©" },
                    { text: "æ—¥æœ¬å¾Œ", explanation: "éŒ¯èª¤ï¼ã€Œå¾Œã€çš„è®€éŸ³æ˜¯ã€Œã”ã€ä½†æ„æ€ä¸åŒ" },
                    { text: "äºŒæœ¬å¾Œ", explanation: "éŒ¯èª¤ï¼é€™æ˜¯éŒ¯èª¤çš„çµ„åˆ" }
                ],
                correctAnswer: 0
            },
            {
                id: 9,
                type: "vocabulary",
                question: "è«‹é¸æ“‡æœ€é©åˆçš„è©èªå¡«å…¥ç©ºæ ¼",
                sentence: "æ˜æ—¥ã¯å¤©æ°—ãŒï¼¿ï¼¿ï¼¿ï¼¿ãã†ã§ã™ã€‚",
                options: [
                    { text: "ã‚ˆã•", explanation: "æ­£ç¢ºï¼å½¢å®¹è©ã€Œã„ã„ã€çš„æ¨é‡å½¢æ˜¯ã€Œã‚ˆã•ã€" },
                    { text: "ã„ã„", explanation: "éŒ¯èª¤ï¼ã€Œã„ã„ã€ä¸èƒ½ç›´æ¥æ¥ã€Œãã†ã§ã™ã€" },
                    { text: "ã‚ˆã„", explanation: "éŒ¯èª¤ï¼éœ€è¦è®Šå½¢ç‚ºã€Œã‚ˆã•ã€" },
                    { text: "ã‚ˆã", explanation: "éŒ¯èª¤ï¼ã€Œã‚ˆãã€æ˜¯å‰¯è©å½¢å¼" }
                ],
                correctAnswer: 0
            },
            {
                id: 10,
                type: "grammar",
                question: "è«‹é¸æ“‡æ­£ç¢ºçš„æ–‡æ³•å½¢å¼",
                sentence: "ã“ã“ã«åå‰ã‚’ï¼¿ï¼¿ï¼¿ï¼¿ãã ã•ã„ã€‚",
                options: [
                    { text: "æ›¸ã„ã¦", explanation: "æ­£ç¢ºï¼ã¦å½¢ç”¨æ–¼è«‹æ±‚" },
                    { text: "æ›¸ã", explanation: "éŒ¯èª¤ï¼éœ€è¦ã¦å½¢" },
                    { text: "æ›¸ã„ãŸ", explanation: "éŒ¯èª¤ï¼é€™æ˜¯éå»å½¢" },
                    { text: "æ›¸ã“ã†", explanation: "éŒ¯èª¤ï¼é€™æ˜¯æ„å¿—å½¢" }
                ],
                correctAnswer: 0
            }
        ];

        window.vocabBank = [
            {
                id: "V0001",
                type: "reading",
                question: "æ¬¡ã®æ¼¢å­—ã®èª­ã¿æ–¹ã‚’é¸ã³ãªã•ã„",
                kanji: "è‡ªåˆ†",
                options: [
                    {text: "ã˜ã¶ã‚“", explanation: "æ­£ç¢ºç­”æ¡ˆï¼šã€Œè‡ªã€éŸ³è®€ç‚ºã€Œã˜ã€ï¼Œã€Œåˆ†ã€éŸ³è®€ç‚ºã€Œã¶ã‚“ã€ï¼Œåˆèµ·ä¾†æ˜¯ã€Œã˜ã¶ã‚“ã€ã€‚\nä¸­æ–‡ç¿»è­¯ï¼šè‡ªå·±"},
                    {text: "ã˜ã·ã‚“", explanation: "éŒ¯èª¤ï¼šã€Œåˆ†ã€çš„è®€éŸ³æ˜¯ã€Œã¶ã‚“ã€ï¼Œä¸æ˜¯ã€Œã·ã‚“ã€ã€‚\nä¸­æ–‡ç¿»è­¯ï¼šè‡ªå·±"},
                    {text: "ã˜ã„ã¶ã‚“", explanation: "éŒ¯èª¤ï¼šã€Œè‡ªã€çš„è®€éŸ³æ˜¯ã€Œã˜ã€ï¼Œæ²’æœ‰é•·éŸ³ã€‚ã€Œåˆ†ã€çš„è®€éŸ³æ˜¯ã€Œã¶ã‚“ã€ã€‚\nä¸­æ–‡ç¿»è­¯ï¼šè‡ªå·±"},
                    {text: "ã˜ãµã‚“", explanation: "éŒ¯èª¤ï¼šã€Œåˆ†ã€çš„è®€éŸ³æ˜¯ã€Œã¶ã‚“ã€ï¼Œä¸æ˜¯ã€Œãµã‚“ã€ã€‚\nä¸­æ–‡ç¿»è­¯ï¼šè‡ªå·±"}
                ],
                correctAnswer: 0
            },
            {
                id: "V0002",
                type: "writing",
                question: "æ¬¡ã®è¨€è‘‰ã®æ­£ã—ã„æ¼¢å­—ã‚’é¸ã³ãªã•ã„",
                kana: "ãŠãã¾ã™",
                options: [
                    {text: "èµ·ãã¾ã™", explanation: "æ­£ç¢ºç­”æ¡ˆï¼šã€ŒãŠãã¾ã™ã€åœ¨æ­¤èªå¢ƒä¸‹å°æ‡‰çš„æ¼¢å­—æ˜¯ã€Œèµ·ãã¾ã™ã€ï¼Œæ„æ€æ˜¯èµ·åºŠã€‚\nä¸­æ–‡ç¿»è­¯ï¼šèµ·åºŠ"},
                    {text: "ç½®ãã¾ã™", explanation: "éŒ¯èª¤ï¼šã€Œç½®ãã¾ã™ã€æ„æ€æ˜¯æ”¾ç½®ï¼Œé›–ç„¶è®€éŸ³ç›¸åŒï¼Œä½†èªæ„ä¸ç¬¦ã€‚\nä¸­æ–‡ç¿»è­¯ï¼šæ”¾ç½®"},
                    {text: "æãã¾ã™", explanation: "éŒ¯èª¤ï¼šã€Œæãã¾ã™ã€è®€éŸ³æ˜¯ã€ŒãˆãŒãã¾ã™ã€æˆ–ã€Œã‹ãã¾ã™ã€ï¼Œæ„æ€æ˜¯æç¹ªã€‚\nä¸­æ–‡ç¿»è­¯ï¼šæç¹ª"},
                    {text: "æ²–ãã¾ã™", explanation: "éŒ¯èª¤ï¼šã€Œæ²–ãã¾ã™ã€è®€éŸ³æ˜¯ã€ŒãŠãã¾ã™ã€ï¼Œä½†æ„æ€æ˜¯æ²–æ´—ï¼Œèªæ„ä¸ç¬¦ã€‚\nä¸­æ–‡ç¿»è­¯ï¼šæ²–æ´—"}
                ],
                correctAnswer: 0
            }
        ];

        // æ‡‰ç”¨ç‹€æ…‹
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let isAnswered = [];
        let score = 0;
        let wrongQuestions = [];
        let selectedQuestions = [];
        let shuffledQuestions = [];
        let questionCount = 30;
        let isPastQuestions = false;
        let isVocabMode = false;
        let timerInterval = null;
        let startTime = null;
        let elapsedTime = 0;
        let history = JSON.parse(localStorage.getItem('n4QuizHistory')) || [];
        let questionBankVersion = localStorage.getItem('questionBankVersion') || '0';
        let lastUpdateCheck = localStorage.getItem('lastUpdateCheck') || 0;

        // ç’°å¢ƒæª¢æ¸¬
        const isLocal = window.location.protocol === 'file:';
        const isDevelopment = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        const isGitHub = window.location.hostname.includes('github.io');

        // ç’°å¢ƒé…ç½®
        const config = {
            enablePWA: !isLocal,
            enableServiceWorker: !isLocal,
            environment: isLocal ? 'local' : (isDevelopment ? 'development' : 'production')
        };

        console.log(`é‹è¡Œç’°å¢ƒ: ${config.environment}, PWA: ${config.enablePWA ? 'å•Ÿç”¨' : 'ç¦ç”¨'}`);

        // DOMå…ƒç´ 
        const countVocabBtn = document.getElementById('count-vocab-btn');
        const homeScreen = document.getElementById('home-screen');
        const quizScreen = document.getElementById('quiz-screen');
        const resultScreen = document.getElementById('result-screen');
        const historyScreen = document.getElementById('history-screen');
        const updateIndicator = document.getElementById('update-indicator');
        
        const startQuizBtn = document.getElementById('start-quiz-btn');
        const viewHistoryBtn = document.getElementById('view-history-btn');
        const exitBtn = document.getElementById('exit-btn');
        const updateBtn = document.getElementById('update-btn');
        const count30Btn = document.getElementById('count-30-btn');
        const count50Btn = document.getElementById('count-50-btn');
        const countPastBtn = document.getElementById('count-past-btn');
        
        const quizContainer = document.getElementById('quiz-container');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const submitBtn = document.getElementById('submit-btn');
        const backHomeBtn = document.getElementById('back-home-btn');
        
        const restartBtn = document.getElementById('restart-btn');
        const resultBackHomeBtn = document.getElementById('result-back-home-btn');
        
        const historyBackHomeBtn = document.getElementById('history-back-home-btn');
        const clearHistoryBtn = document.getElementById('clear-history-btn');
        
        const progressElement = document.getElementById('progress');
        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');
        const resultElement = document.getElementById('result');
        const historyListElement = document.getElementById('history-list');

        // ========== æ ¸å¿ƒåŠŸèƒ½å‡½æ•¸ ==========

        // ä¿®æ”¹é–‹å§‹æ¸¬é©—å‡½æ•¸
        function startQuiz() {
            // æª¢æŸ¥é¡Œåº«æ˜¯å¦å·²åŠ è¼‰
            if (isVocabMode) {
                // å–®å­—æ¸¬é©—æ¨¡å¼
                if (!window.vocabBank || window.vocabBank.length === 0) {
                    alert('å–®å­—é¡Œåº«åŠ è¼‰ä¸­ï¼Œè«‹ç¨å¾Œå†è©¦...');
                    loadQuestionBank();
                    return;
                }
                startVocabQuiz();
            } else if (isPastQuestions) {
                // æ­·å±†è€ƒé¡Œæ¨¡å¼
                if (!window.pastQuestionBank || window.pastQuestionBank.length === 0) {
                    alert('æ­·å±†è€ƒé¡Œåº«åŠ è¼‰ä¸­ï¼Œè«‹ç¨å¾Œå†è©¦...');
                    loadQuestionBank();
                    return;
                }
                startPastQuiz();
            } else {
                // ä¸€èˆ¬æ–‡æ³•æ¸¬é©—æ¨¡å¼
                if (!window.questionBank || window.questionBank.length === 0) {
                    alert('é¡Œåº«åŠ è¼‰ä¸­ï¼Œè«‹ç¨å¾Œå†è©¦...');
                    loadQuestionBank();
                    return;
                }
                startGrammarQuiz();
            }
        }

        // å–®å­—æ¸¬é©—é–‹å§‹å‡½æ•¸
        function startVocabQuiz() {
            // é‡ç½®ç‹€æ…‹
            currentQuestionIndex = 0;
            userAnswers = [];
            isAnswered = [];
            score = 0;
            wrongQuestions = [];
            selectedQuestions = [];
            shuffledQuestions = [];
            elapsedTime = 0;

            // éš¨æ©Ÿé¸æ“‡å–®å­—é¡Œç›®
            const shuffled = shuffleArray([...window.vocabBank]);
            selectedQuestions = shuffled.slice(0, Math.min(questionCount, window.vocabBank.length));
            
            // éš¨æ©Ÿæ‰“äº‚æ¯å€‹é¡Œç›®çš„é¸é …é †åº
            shuffledQuestions = selectedQuestions.map(question => shuffleOptions(question));
            
            userAnswers = new Array(selectedQuestions.length).fill(null);
            isAnswered = new Array(selectedQuestions.length).fill(false);
            
            // é–‹å§‹è¨ˆæ™‚
            startTimer();
            
            // é¡¯ç¤ºæ¸¬é©—é é¢
            showScreen(quizScreen);
            displayQuestion(currentQuestionIndex);
            updateButtons();
            updateProgress();
        }

        // æ–‡æ³•æ¸¬é©—é–‹å§‹å‡½æ•¸
        function startGrammarQuiz() {
            // é‡ç½®ç‹€æ…‹
            currentQuestionIndex = 0;
            userAnswers = [];
            isAnswered = [];
            score = 0;
            wrongQuestions = [];
            selectedQuestions = [];
            shuffledQuestions = [];
            elapsedTime = 0;

            // éš¨æ©Ÿé¸æ“‡é¡Œç›®
            const shuffled = shuffleArray([...window.questionBank]);
            selectedQuestions = shuffled.slice(0, Math.min(questionCount, window.questionBank.length));
            
            // éš¨æ©Ÿæ‰“äº‚æ¯å€‹é¡Œç›®çš„é¸é …é †åº
            shuffledQuestions = selectedQuestions.map(question => shuffleOptions(question));
            
            userAnswers = new Array(selectedQuestions.length).fill(null);
            isAnswered = new Array(selectedQuestions.length).fill(false);
            
            // é–‹å§‹è¨ˆæ™‚
            startTimer();
            
            // é¡¯ç¤ºæ¸¬é©—é é¢
            showScreen(quizScreen);
            displayQuestion(currentQuestionIndex);
            updateButtons();
            updateProgress();
        }

        // æ­·å±†è€ƒé¡Œé–‹å§‹å‡½æ•¸
        function startPastQuiz() {
            // é‡ç½®ç‹€æ…‹
            currentQuestionIndex = 0;
            userAnswers = [];
            isAnswered = [];
            score = 0;
            wrongQuestions = [];
            selectedQuestions = [];
            shuffledQuestions = [];
            elapsedTime = 0;

            // éš¨æ©Ÿé¸æ“‡é¡Œç›®
            const shuffled = shuffleArray([...window.pastQuestionBank]);
            selectedQuestions = shuffled.slice(0, Math.min(questionCount, window.pastQuestionBank.length));
            
            // éš¨æ©Ÿæ‰“äº‚æ¯å€‹é¡Œç›®çš„é¸é …é †åº
            shuffledQuestions = selectedQuestions.map(question => shuffleOptions(question));
            
            userAnswers = new Array(selectedQuestions.length).fill(null);
            isAnswered = new Array(selectedQuestions.length).fill(false);
            
            // é–‹å§‹è¨ˆæ™‚
            startTimer();
            
            // é¡¯ç¤ºæ¸¬é©—é é¢
            showScreen(quizScreen);
            displayQuestion(currentQuestionIndex);
            updateButtons();
            updateProgress();
        }

        // é¡¯ç¤ºæ­·å²ç´€éŒ„
        function showHistory() {
            displayHistory();
            showScreen(historyScreen);
        }

        // çµæŸæ‡‰ç”¨ç¨‹å¼
        function exitApp() {
            if (confirm('ç¢ºå®šè¦çµæŸæ¸¬é©—å—ï¼Ÿ')) {
                // åœ¨ç€è¦½å™¨ä¸­ï¼Œæˆ‘å€‘ç„¡æ³•ç›´æ¥é—œé–‰è¦–çª—ï¼Œé™¤éæ˜¯PWA
                if (window.navigator.standalone) {
                    window.close();
                } else {
                    showUpdateNotification('è«‹æ‰‹å‹•é—œé–‰ç€è¦½å™¨æ¨™ç±¤é ');
                }
            }
        }

        // è¿”å›é¦–é 
        function backToHome() {
            stopTimer();
            showScreen(homeScreen);
        }

        // ä¸Šä¸€é¡Œ
        function prevQuestion() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                displayQuestion(currentQuestionIndex);
                updateButtons();
                updateProgress();
            }
        }

        // ä¸‹ä¸€é¡Œ
        function nextQuestion() {
            if (currentQuestionIndex < shuffledQuestions.length - 1) {
                currentQuestionIndex++;
                displayQuestion(currentQuestionIndex);
                updateButtons();
                updateProgress();
            }
        }

        // æäº¤æ¸¬é©—
        function submitQuiz() {
            stopTimer();
            
            // å„²å­˜æ­·å²ç´€éŒ„
            const record = {
                date: new Date().toISOString(),
                score: score,
                total: shuffledQuestions.length,
                time: elapsedTime,
                wrongQuestions: [...wrongQuestions]
            };
            
            history.unshift(record);
            // åªä¿ç•™æœ€è¿‘10æ¬¡ç´€éŒ„
            if (history.length > 10) {
                history = history.slice(0, 10);
            }
            
            localStorage.setItem('n4QuizHistory', JSON.stringify(history));
            
            showResults();
            showScreen(resultScreen);
        }

        // é‡æ–°é–‹å§‹æ¸¬é©—
        function restartQuiz() {
            startQuiz();
        }

        // è¨­å®šé¡Œç›®æ•¸é‡å’Œæ¸¬é©—é¡å‹
        function setQuestionCount(count) {
            if (count === 'past') {
                // æ­·å±†è€ƒé¡Œæ¨¡å¼
                isPastQuestions = true;
                isVocabMode = false;
                const maxAvailable = window.pastQuestionBank ? window.pastQuestionBank.length : 0;
                questionCount = maxAvailable;
                
                // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
                updateCountButtonStates('past');
                
                if (maxAvailable === 0) {
                    showUpdateNotification('æ­·å±†è€ƒé¡Œåº«ç‚ºç©º');
                    return;
                }
                
                showUpdateNotification(`æ­·å±†è€ƒé¡Œæ¨¡å¼ (${maxAvailable}é¡Œ)`);
            } else if (count === 'vocab') {
                // å–®å­—æ¸¬é©—æ¨¡å¼
                isPastQuestions = false;
                isVocabMode = true;
                const maxAvailable = window.vocabBank ? window.vocabBank.length : 0;
                questionCount = maxAvailable;
                
                // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
                updateCountButtonStates('vocab');
                
                if (maxAvailable === 0) {
                    showUpdateNotification('å–®å­—é¡Œåº«ç‚ºç©º');
                    return;
                }
                
                showUpdateNotification(`å–®å­—æ¸¬é©—æ¨¡å¼ (${maxAvailable}é¡Œ)`);
            } else {
                // ä¸€èˆ¬é¡Œåº«æ¨¡å¼
                isPastQuestions = false;
                isVocabMode = false;
                const maxAvailable = window.questionBank ? window.questionBank.length : 0;
                questionCount = Math.min(count, maxAvailable);
                
                // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
                updateCountButtonStates(count);
                
                // å¦‚æœé¸æ“‡çš„æ•¸é‡è¶…éå¯ç”¨é¡Œç›®ï¼Œé¡¯ç¤ºæç¤º
                if (count > maxAvailable && maxAvailable > 0) {
                    showUpdateNotification(`å¯ç”¨é¡Œç›®åªæœ‰ ${maxAvailable} é¡Œ`);
                    questionCount = maxAvailable;
                }
            }
        }

        // æ›´æ–°æ•¸é‡é¸æ“‡æŒ‰éˆ•ç‹€æ…‹
        function updateCountButtonStates(selectedType) {
            // ç§»é™¤æ‰€æœ‰æŒ‰éˆ•çš„activeé¡åˆ¥
            count30Btn.classList.remove('active');
            count50Btn.classList.remove('active');
            countPastBtn.classList.remove('active');
            countVocabBtn.classList.remove('active');
            
            // æ ¹æ“šé¸æ“‡çš„é¡å‹æ·»åŠ activeé¡åˆ¥
            switch(selectedType) {
                case 30:
                    count30Btn.classList.add('active');
                    break;
                case 50:
                    count50Btn.classList.add('active');
                    break;
                case 'past':
                    countPastBtn.classList.add('active');
                    break;
                case 'vocab':
                    countVocabBtn.classList.add('active');
                    break;
            }
        }

        // åˆå§‹åŒ–äº‹ä»¶ç›£è½å™¨
        function initEventListeners() {
            // é¦–é æŒ‰éˆ•
            startQuizBtn.addEventListener('click', startQuiz);
            viewHistoryBtn.addEventListener('click', showHistory);
            exitBtn.addEventListener('click', exitApp);
            updateBtn.addEventListener('click', checkForUpdates);
            
            // æ¸¬é©—é¡å‹é¸æ“‡æŒ‰éˆ•
            count30Btn.addEventListener('click', () => setQuestionCount(30));
            count50Btn.addEventListener('click', () => setQuestionCount(50));
            countPastBtn.addEventListener('click', () => setQuestionCount('past'));
            countVocabBtn.addEventListener('click', () => setQuestionCount('vocab'));
            
            // æ¸¬é©—é é¢æŒ‰éˆ•
            prevBtn.addEventListener('click', prevQuestion);
            nextBtn.addEventListener('click', nextQuestion);
            submitBtn.addEventListener('click', submitQuiz);
            backHomeBtn.addEventListener('click', backToHome);
            
            // çµæœé é¢æŒ‰éˆ•
            restartBtn.addEventListener('click', restartQuiz);
            resultBackHomeBtn.addEventListener('click', backToHome);
            
            // æ­·å²ç´€éŒ„é é¢æŒ‰éˆ•
            historyBackHomeBtn.addEventListener('click', backToHome);
            clearHistoryBtn.addEventListener('click', clearHistory);
        }

        // ========== å…¶ä»–åŠŸèƒ½å‡½æ•¸ ==========

// 1. é¦–å…ˆæ·»åŠ ç¼ºå¤±çš„ loadJSONBank å‡½æ•¸
async function loadJSONBank(url, bankName) {
    try {
        const response = await fetch(url + '?t=' + Date.now());
        if (!response.ok) return false;
        
        const data = await response.json();
        if (Array.isArray(data)) {
            window[bankName] = data;
            console.log(`âœ… ${bankName} JSON è¼‰å…¥æˆåŠŸ`);
            return true;
        }
    } catch (e) {
        console.log(`${bankName} JSON è¼‰å…¥å¤±æ•—:`, e);
    }
    return false;
}

async function safeLoadBank(url, bankName) {
    try {
        const response = await fetch(url + '?t=' + Date.now());
        if (!response.ok) return false;
        
        const text = await response.text();
        console.log(`${bankName} åŸå§‹å…§å®¹é•·åº¦:`, text.length);
        
        // å˜—è©¦å¤šç¨®è§£ææ–¹å¼
        let parsedData = null;
        
        // æ–¹å¼1: ç›´æ¥ä½œç‚º JavaScript åŸ·è¡Œï¼ˆå¦‚æœåŒ…å«è®Šæ•¸è³¦å€¼ï¼‰
        if (text.includes(`window.${bankName}`) || text.includes(`${bankName} =`)) {
            try {
                eval(text);
                if (window[bankName] && Array.isArray(window[bankName])) {
                    console.log(`âœ… ${bankName} é€é eval è¼‰å…¥æˆåŠŸ`);
                    return true;
                }
            } catch (e) {
                console.log(`${bankName} eval å¤±æ•—:`, e);
            }
        }
        
        // æ–¹å¼2: ä½œç‚ºç´” JSON è§£æ
        try {
            const trimmed = text.trim();
            // ç§»é™¤å¯èƒ½çš„åˆ†è™Ÿ
            const cleanText = trimmed.replace(/;+$/, '');
            
            if (cleanText.startsWith('[')) {
                parsedData = JSON.parse(cleanText);
            } else if (cleanText.startsWith('{')) {
                const obj = JSON.parse(cleanText);
                // æª¢æŸ¥æ˜¯å¦æ˜¯åŒ…å«é¡Œç›®çš„ç‰©ä»¶
                if (obj.questions && Array.isArray(obj.questions)) {
                    parsedData = obj.questions;
                } else if (Array.isArray(obj)) {
                    parsedData = obj;
                }
            }
            
            if (parsedData && Array.isArray(parsedData)) {
                window[bankName] = parsedData;
                console.log(`âœ… ${bankName} é€é JSON è§£æè¼‰å…¥æˆåŠŸ`);
                return true;
            }
        } catch (e) {
            console.log(`${bankName} JSON è§£æå¤±æ•—:`, e);
        }
        
        // æ–¹å¼3: å˜—è©¦æå–é™£åˆ—
        try {
            // å°‹æ‰¾é™£åˆ—é–‹å§‹å’ŒçµæŸçš„ä½ç½®
            const arrayStart = text.indexOf('[');
            const arrayEnd = text.lastIndexOf(']') + 1;
            
            if (arrayStart !== -1 && arrayEnd !== -1 && arrayEnd > arrayStart) {
                const arrayText = text.substring(arrayStart, arrayEnd);
                parsedData = JSON.parse(arrayText);
                
                if (Array.isArray(parsedData)) {
                    window[bankName] = parsedData;
                    console.log(`âœ… ${bankName} é€éé™£åˆ—æå–è¼‰å…¥æˆåŠŸ`);
                    return true;
                }
            }
        } catch (e) {
            console.log(`${bankName} é™£åˆ—æå–å¤±æ•—:`, e);
        }
        
    } catch (e) {
        console.log(`${bankName} è¼‰å…¥å¤±æ•—:`, e);
    }
    
    console.log(`âŒ ${bankName} æ‰€æœ‰è§£ææ–¹å¼éƒ½å¤±æ•—`);
    return false;
}

// 3. æ›¿æ›ç¾æœ‰çš„ loadQuestionBank å‡½æ•¸
async function loadQuestionBank() {
    console.log('é–‹å§‹è¼‰å…¥é¡Œåº«...');
    
    // å…ˆç¦ç”¨é–‹å§‹æ¸¬é©—æŒ‰éˆ•
    startQuizBtn.disabled = true;
    startQuizBtn.textContent = 'é¡Œåº«è¼‰å…¥ä¸­...';
    
    let loadedCount = 0;
    
    // å¦‚æœæ˜¯ç·šä¸Šç’°å¢ƒï¼Œå˜—è©¦è¼‰å…¥å¤–éƒ¨é¡Œåº«
    if (!isLocal) {
        console.log('ç·šä¸Šç’°å¢ƒï¼šå˜—è©¦è¼‰å…¥å¤–éƒ¨é¡Œåº«');
        
        // å˜—è©¦è¼‰å…¥ä¸€èˆ¬é¡Œåº«
        if (await safeLoadBank('./question_bank.js', 'questionBank') || 
            await loadJSONBank('./question_bank.json', 'questionBank')) {
            loadedCount++;
            console.log('âœ… ä¸€èˆ¬é¡Œåº«è¼‰å…¥æˆåŠŸï¼Œé¡Œç›®æ•¸é‡:', window.questionBank.length);
        }
        
        // å˜—è©¦è¼‰å…¥æ­·å±†è€ƒé¡Œ
        if (await safeLoadBank('./pastQuestionBank.js', 'pastQuestionBank') || 
            await loadJSONBank('./pastQuestionBank.json', 'pastQuestionBank')) {
            loadedCount++;
            console.log('âœ… æ­·å±†è€ƒé¡Œåº«è¼‰å…¥æˆåŠŸï¼Œé¡Œç›®æ•¸é‡:', window.pastQuestionBank.length);
        }
        
        // å˜—è©¦è¼‰å…¥å–®å­—é¡Œåº«
        if (await safeLoadBank('./vocab_bank.js', 'vocabBank') || 
            await loadJSONBank('./vocab_bank.json', 'vocabBank')) {
            loadedCount++;
            console.log('âœ… å–®å­—é¡Œåº«è¼‰å…¥æˆåŠŸï¼Œé¡Œç›®æ•¸é‡:', window.vocabBank.length);
        }
    } else {
        console.log('æœ¬åœ°ç’°å¢ƒï¼šä½¿ç”¨å…§å»ºé¡Œåº«');
    }
    
    // ç¢ºä¿æ‰€æœ‰é¡Œåº«éƒ½æœ‰é è¨­å€¼
    window.questionBank = window.questionBank || [];
    window.pastQuestionBank = window.pastQuestionBank || [];
    window.vocabBank = window.vocabBank || [];
    
    console.log('ğŸ“Š æœ€çµ‚é¡Œåº«çµ±è¨ˆ:');
    console.log('- ä¸€èˆ¬é¡Œåº«é¡Œç›®æ•¸é‡:', window.questionBank.length);
    console.log('- æ­·å±†è€ƒé¡Œé¡Œç›®æ•¸é‡:', window.pastQuestionBank.length);
    console.log('- å–®å­—é¡Œåº«é¡Œç›®æ•¸é‡:', window.vocabBank.length);
    console.log('- æˆåŠŸè¼‰å…¥çš„å¤–éƒ¨é¡Œåº«æ•¸é‡:', loadedCount);
    
    // å•Ÿç”¨é–‹å§‹æ¸¬é©—æŒ‰éˆ•
    startQuizBtn.disabled = false;
    startQuizBtn.textContent = 'é–‹å§‹æ¸¬é©—';
    
    // æ›´æ–°é¡Œç›®æ•¸é‡é¸æ“‡å™¨
    setQuestionCount(questionCount);
    
    if (loadedCount > 0) {
        showUpdateNotification(`æˆåŠŸè¼‰å…¥ ${loadedCount} å€‹å¤–éƒ¨é¡Œåº«`);
    } else {
        showUpdateNotification('ä½¿ç”¨å…§å»ºé¡Œåº«æ¨¡å¼');
    }
}

// æ¸…ç†é¡Œåº«æ–‡å­—å…§å®¹çš„è¼”åŠ©å‡½æ•¸
function cleanQuestionBankText(text, bankName) {
    let cleaned = text.trim();
    
    // ç§»é™¤å¯èƒ½çš„ BOM å­—å…ƒ
    if (cleaned.charCodeAt(0) === 0xFEFF) {
        cleaned = cleaned.substring(1);
    }
    
    // æª¢æŸ¥æ˜¯å¦å·²ç¶“æ˜¯æœ‰æ•ˆçš„è®Šæ•¸è³¦å€¼
    if (cleaned.startsWith(`window.${bankName}`) || cleaned.startsWith(bankName)) {
        return cleaned;
    }
    
    // å¦‚æœæ˜¯ç´”é™£åˆ—ï¼ŒåŒ…è£æˆè®Šæ•¸è³¦å€¼
    if (cleaned.startsWith('[')) {
        return `window.${bankName} = ${cleaned};`;
    }
    
    // å¦‚æœæ˜¯ JSON ç‰©ä»¶ï¼Œå˜—è©¦è§£æ
    if (cleaned.startsWith('{')) {
        try {
            const data = JSON.parse(cleaned);
            if (data.questions) {
                return `window.${bankName} = ${JSON.stringify(data.questions)};`;
            } else {
                return `window.${bankName} = ${cleaned};`;
            }
        } catch (e) {
            console.log(`ç„¡æ³•è§£æ ${bankName} ç‚º JSON:`, e);
        }
    }
    
    // å¦‚æœä»¥ä¸Šéƒ½ä¸ç¬¦åˆï¼Œå˜—è©¦ç›´æ¥åŒ…è£
    console.log(`âš ï¸ ${bankName} æ ¼å¼ä¸ç¢ºå®šï¼Œå˜—è©¦ç›´æ¥åŒ…è£`);
    return `window.${bankName} = ${cleaned};`;
}

// æª¢æŸ¥é¡Œåº«ç‰ˆæœ¬æ›´æ–°
function checkQuestionBankUpdate() {
    const now = new Date().getTime();
    const oneDay = 24 * 60 * 60 * 1000; // 1å¤©çš„æ¯«ç§’æ•¸
    
    // å¦‚æœè¶…é1å¤©æ²’æœ‰æª¢æŸ¥æ›´æ–°ï¼Œæˆ–è€…å¼·åˆ¶æ›´æ–°
    if (now - lastUpdateCheck > oneDay || !localStorage.getItem('cachedQuestionBank')) {
        console.log('æª¢æŸ¥é¡Œåº«æ›´æ–°...');
        updateQuestionBankCache();
    } else {
        console.log('ä½¿ç”¨ç·©å­˜çš„é¡Œåº«ç‰ˆæœ¬');
    }
    
    localStorage.setItem('lastUpdateCheck', now.toString());
}

        // æ›´æ–°é¡Œåº«ç·©å­˜
        function updateQuestionBankCache() {
            if (window.questionBank && window.questionBank.length > 0) {
                const newVersion = generateQuestionBankVersion(window.questionBank);
                const currentVersion = localStorage.getItem('questionBankVersion');
                
                if (newVersion !== currentVersion) {
                    console.log('ç™¼ç¾æ–°ç‰ˆæœ¬é¡Œåº«ï¼Œæ›´æ–°ç·©å­˜');
                    
                    // ç·©å­˜é¡Œåº«æ•¸æ“š
                    localStorage.setItem('cachedQuestionBank', JSON.stringify(window.questionBank));
                    localStorage.setItem('questionBankVersion', newVersion);
                    
                    showUpdateNotification('é¡Œåº«å·²æ›´æ–°åˆ°æœ€æ–°ç‰ˆæœ¬ï¼');
                    updateIndicator.classList.remove('outdated');
                } else {
                    console.log('é¡Œåº«å·²æ˜¯æœ€æ–°ç‰ˆæœ¬');
                    updateIndicator.classList.remove('outdated');
                }
            }
        }

        // ç”Ÿæˆé¡Œåº«ç‰ˆæœ¬æ¨™è­˜
        function generateQuestionBankVersion(bank) {
            const contentString = JSON.stringify(bank);
            let hash = 0;
            for (let i = 0; i < contentString.length; i++) {
                const char = contentString.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return 'v1.' + Math.abs(hash).toString(16).substring(0, 8);
        }

        // é¡¯ç¤ºæ›´æ–°é€šçŸ¥
        function showUpdateNotification(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #3498db;
                color: white;
                padding: 10px 15px;
                border-radius: 5px;
                z-index: 1000;
                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            `;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                if (toast.parentNode) {
                    document.body.removeChild(toast);
                }
            }, 3000);
        }

        // æ‰‹å‹•æª¢æŸ¥æ›´æ–°å‡½æ•¸
        function checkForUpdates() {
            console.log('æ‰‹å‹•æª¢æŸ¥é¡Œåº«æ›´æ–°...');
            showUpdateNotification('å·²æª¢æŸ¥æ›´æ–°ï¼Œä½¿ç”¨å…§å»ºé¡Œåº«');
            updateIndicator.classList.remove('outdated');
        }

        // é–‹å§‹è¨ˆæ™‚
        function startTimer() {
            startTime = new Date();
            timerInterval = setInterval(updateTimer, 1000);
        }

        // æ›´æ–°è¨ˆæ™‚å™¨
        function updateTimer() {
            const now = new Date();
            elapsedTime = Math.floor((now - startTime) / 1000);
            
            const minutes = Math.floor(elapsedTime / 60);
            const seconds = elapsedTime % 60;
            
            timerElement.textContent = `æ™‚é–“: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // åœæ­¢è¨ˆæ™‚
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        // é¡¯ç¤ºæ­·å²ç´€éŒ„å…§å®¹
        function displayHistory() {
            if (history.length === 0) {
                historyListElement.innerHTML = '<p>å°šç„¡æ¸¬é©—ç´€éŒ„</p>';
                return;
            }
            
            let historyHTML = '';
            
            history.forEach((record, index) => {
                const date = new Date(record.date).toLocaleString('zh-TW');
                
                // è¨ˆç®—å„é¡Œå‹çš„éŒ¯èª¤æ•¸é‡
                const errorTypes = {
                    reading: 0,
                    writing: 0,
                    vocabulary: 0,
                    synonym: 0,
                    grammar: 0,
                    reorder: 0
                };
                
                record.wrongQuestions.forEach(questionId => {
                    // å…ˆå¾ä¸€èˆ¬é¡Œåº«æ‰¾ï¼Œå†å¾æ­·å±†è€ƒé¡Œåº«æ‰¾
                    let question = window.questionBank.find(q => q.id === questionId);
                    if (!question) {
                        question = window.pastQuestionBank.find(q => q.id === questionId);
                    }
                    if (question && errorTypes.hasOwnProperty(question.type)) {
                        errorTypes[question.type]++;
                    }
                });
                
                historyHTML += `
                    <div class="history-item">
                        <div class="history-date">æ¸¬é©— ${index + 1} - ${date}</div>
                        <div class="history-stats">
                            <div class="history-stat">ç­”å°é¡Œæ•¸: ${record.score}/${record.total}</div>
                            <div class="history-stat">ç”¨æ™‚: ${formatTime(record.time)}</div>
                            <div class="history-stat">æ¼¢å­—è®€éŸ³éŒ¯èª¤: ${errorTypes.reading}</div>
                            <div class="history-stat">æ¼¢å­—æ›¸å¯«éŒ¯èª¤: ${errorTypes.writing}</div>
                            <div class="history-stat">è©èªå¡«ç©ºéŒ¯èª¤: ${errorTypes.vocabulary}</div>
                            <div class="history-stat">è¿‘ç¾©è©æ›¿æ›éŒ¯èª¤: ${errorTypes.synonym}</div>
                            <div class="history-stat">æ–‡æ³•é¸æ“‡éŒ¯èª¤: ${errorTypes.grammar}</div>
                            <div class="history-stat">å¥å­é‡çµ„éŒ¯èª¤: ${errorTypes.reorder}</div>
                        </div>
                    </div>
                `;
            });
            
            historyListElement.innerHTML = historyHTML;
        }

        // æ ¼å¼åŒ–æ™‚é–“é¡¯ç¤º
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // æ¸…é™¤æ­·å²ç´€éŒ„
        function clearHistory() {
            if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰æ­·å²ç´€éŒ„å—ï¼Ÿ')) {
                history = [];
                localStorage.setItem('n4QuizHistory', JSON.stringify(history));
                displayHistory();
            }
        }

        // é¡¯ç¤ºæŒ‡å®šç•«é¢
        function showScreen(screen) {
            homeScreen.classList.remove('active');
            quizScreen.classList.remove('active');
            resultScreen.classList.remove('active');
            historyScreen.classList.remove('active');
            
            screen.classList.add('active');
        }

        // éš¨æ©Ÿæ‰“äº‚é™£åˆ—
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // éš¨æ©Ÿæ‰“äº‚é¸é …é †åº
        function shuffleOptions(question) {
            const optionsWithIndex = question.options.map((option, index) => ({...option, originalIndex: index}));
            const shuffledOptions = shuffleArray(optionsWithIndex);
            
            // æ›´æ–°æ­£ç¢ºç­”æ¡ˆçš„ç´¢å¼•
            const newCorrectAnswerIndex = shuffledOptions.findIndex(option => option.originalIndex === question.correctAnswer);
            
            return {
                ...question,
                options: shuffledOptions.map(option => ({text: option.text, explanation: option.explanation})),
                correctAnswer: newCorrectAnswerIndex
            };
        }

        // é¡¯ç¤ºé¡Œç›®
        function displayQuestion(index) {
            const question = shuffledQuestions[index];
            let questionHTML = '';
            
            // æ ¹æ“šé¡Œå‹ç”Ÿæˆä¸åŒçš„HTML
            switch(question.type) {
                case "reading":
                    questionHTML = generateReadingQuestion(question, index);
                    break;
                case "writing":
                    questionHTML = generateWritingQuestion(question, index);
                    break;
                case "vocabulary":
                    questionHTML = generateVocabularyQuestion(question, index);
                    break;
                case "synonym":
                    questionHTML = generateSynonymQuestion(question, index);
                    break;
                case "grammar":
                    questionHTML = generateGrammarQuestion(question, index);
                    break;
                case "reorder":
                    questionHTML = generateReorderQuestion(question, index);
                    break;
                default:
                    questionHTML = generateDefaultQuestion(question, index);
            }
            
            const explanationClass = isAnswered[index] ? 'explanation show' : 'explanation';
            questionHTML += `
                <div class="${explanationClass}">
                    <div class="explanation-title">è§£èªªï¼š</div>
                    ${isAnswered[index] ? generateOptionExplanations(question) : question.options[question.correctAnswer].explanation}
                </div>
            `;
            
            quizContainer.innerHTML = questionHTML;
        }

        // ç”Ÿæˆé¸é …è§£æ
        function generateOptionExplanations(question) {
            let explanationsHTML = '';
            
            question.options.forEach((option, i) => {
                const isCorrect = i === question.correctAnswer;
                const isSelected = userAnswers[currentQuestionIndex] === i;
                
                explanationsHTML += `
                    <div class="option-explanation" style="${isCorrect ? 'border-left: 4px solid #28a745;' : isSelected ? 'border-left: 4px solid #dc3545;' : ''}">
                        <strong>é¸é … ${i+1}: ${option.text}</strong><br>
                        ${option.explanation}
                    </div>
                `;
            });
            
            return explanationsHTML;
        }

        // ç”Ÿæˆæ¼¢å­—è®€éŸ³é¡Œå‹
        function generateReadingQuestion(question, index) {
            let optionsHTML = '';
            
            question.options.forEach((option, i) => {
                const isSelected = userAnswers[index] === i;
                const isCorrect = isAnswered[index] && i === question.correctAnswer;
                const isIncorrect = isAnswered[index] && isSelected && i !== question.correctAnswer;
                
                let optionClass = 'option';
                if (isSelected) optionClass += ' selected';
                if (isCorrect) optionClass += ' correct';
                if (isIncorrect) optionClass += ' incorrect';
                
                optionsHTML += `
                    <div class="${optionClass}" onclick="window.selectOption(${i})">
                        ${option.text}
                    </div>
                `;
            });
            
            // å¦‚æœæ˜¯æ­·å±†è€ƒé¡Œï¼Œé¡¯ç¤ºå¹´ä»½è³‡è¨Š
            const yearInfo = question.year && question.season ? 
                `<div style="font-size: 14px; color: #666; margin-bottom: 10px;">${question.year}å¹´ ${question.season}è€ƒé¡Œ</div>` : '';
            
            return `
                <div class="question">
                    <div class="question-number">å•é¡Œ ${index + 1}</div>
                    ${yearInfo}
                    <div class="question-text">${question.question}</div>
                    <div class="kanji">${question.kanji}</div>
                    <div class="options">
                        ${optionsHTML}
                    </div>
                </div>
            `;
        }

        // ç”Ÿæˆæ¼¢å­—æ›¸å¯«é¡Œå‹
        function generateWritingQuestion(question, index) {
            let optionsHTML = '';
            
            question.options.forEach((option, i) => {
                const isSelected = userAnswers[index] === i;
                const isCorrect = isAnswered[index] && i === question.correctAnswer;
                const isIncorrect = isAnswered[index] && isSelected && i !== question.correctAnswer;
                
                let optionClass = 'option';
                if (isSelected) optionClass += ' selected';
                if (isCorrect) optionClass += ' correct';
                if (isIncorrect) optionClass += ' incorrect';
                
                optionsHTML += `
                    <div class="${optionClass}" onclick="window.selectOption(${i})">
                        ${option.text}
                    </div>
                `;
            });
            
            // å¦‚æœæ˜¯æ­·å±†è€ƒé¡Œï¼Œé¡¯ç¤ºå¹´ä»½è³‡è¨Š
            const yearInfo = question.year && question.season ? 
                `<div style="font-size: 14px; color: #666; margin-bottom: 10px;">${question.year}å¹´ ${question.season}è€ƒé¡Œ</div>` : '';
            
            return `
                <div class="question">
                    <div class="question-number">å•é¡Œ ${index + 1}</div>
                    ${yearInfo}
                    <div class="question-text">${question.question}</div>
                    <div class="kanji">${question.kana}</div>
                    <div class="options">
                        ${optionsHTML}
                    </div>
                </div>
            `;
        }

        // ç”Ÿæˆè©èªå¡«ç©ºé¡Œå‹
        function generateVocabularyQuestion(question, index) {
            let optionsHTML = '';
            
            question.options.forEach((option, i) => {
                const isSelected = userAnswers[index] === i;
                const isCorrect = isAnswered[index] && i === question.correctAnswer;
                const isIncorrect = isAnswered[index] && isSelected && i !== question.correctAnswer;
                
                let optionClass = 'option';
                if (isSelected) optionClass += ' selected';
                if (isCorrect) optionClass += ' correct';
                if (isIncorrect) optionClass += ' incorrect';
                
                optionsHTML += `
                    <div class="${optionClass}" onclick="window.selectOption(${i})">
                        ${option.text}
                    </div>
                `;
            });
            
            // å¦‚æœæ˜¯æ­·å±†è€ƒé¡Œï¼Œé¡¯ç¤ºå¹´ä»½è³‡è¨Š
            const yearInfo = question.year && question.season ? 
                `<div style="font-size: 14px; color: #666; margin-bottom: 10px;">${question.year}å¹´ ${question.season}è€ƒé¡Œ</div>` : '';
            
            return `
                <div class="question">
                    <div class="question-number">å•é¡Œ ${index + 1}</div>
                    ${yearInfo}
                    <div class="question-text">${question.question}</div>
                    <div class="question-text">${question.sentence}</div>
                    <div class="options">
                        ${optionsHTML}
                    </div>
                </div>
            `;
        }

        // ç”Ÿæˆè¿‘ç¾©è©æ›¿æ›é¡Œå‹
        function generateSynonymQuestion(question, index) {
            let optionsHTML = '';
            
            question.options.forEach((option, i) => {
                const isSelected = userAnswers[index] === i;
                const isCorrect = isAnswered[index] && i === question.correctAnswer;
                const isIncorrect = isAnswered[index] && isSelected && i !== question.correctAnswer;
                
                let optionClass = 'option';
                if (isSelected) optionClass += ' selected';
                if (isCorrect) optionClass += ' correct';
                if (isIncorrect) optionClass += ' incorrect';
                
                optionsHTML += `
                    <div class="${optionClass}" onclick="window.selectOption(${i})">
                        ${option.text}
                    </div>
                `;
            });
            
            // å¦‚æœæ˜¯æ­·å±†è€ƒé¡Œï¼Œé¡¯ç¤ºå¹´ä»½è³‡è¨Š
            const yearInfo = question.year && question.season ? 
                `<div style="font-size: 14px; color: #666; margin-bottom: 10px;">${question.year}å¹´ ${question.season}è€ƒé¡Œ</div>` : '';
            
            return `
                <div class="question">
                    <div class="question-number">å•é¡Œ ${index + 1}</div>
                    ${yearInfo}
                    <div class="question-text">${question.question}</div>
                    <div class="question-text">${question.sentence}</div>
                    <div class="options">
                        ${optionsHTML}
                    </div>
                </div>
            `;
        }

        // ç”Ÿæˆæ–‡æ³•é¸æ“‡é¡Œå‹
        function generateGrammarQuestion(question, index) {
            let optionsHTML = '';
            
            question.options.forEach((option, i) => {
                const isSelected = userAnswers[index] === i;
                const isCorrect = isAnswered[index] && i === question.correctAnswer;
                const isIncorrect = isAnswered[index] && isSelected && i !== question.correctAnswer;
                
                let optionClass = 'option';
                if (isSelected) optionClass += ' selected';
                if (isCorrect) optionClass += ' correct';
                if (isIncorrect) optionClass += ' incorrect';
                
                optionsHTML += `
                    <div class="${optionClass}" onclick="window.selectOption(${i})">
                        ${option.text}
                    </div>
                `;
            });
            
            // å¦‚æœæ˜¯æ­·å±†è€ƒé¡Œï¼Œé¡¯ç¤ºå¹´ä»½è³‡è¨Š
            const yearInfo = question.year && question.season ? 
                `<div style="font-size: 14px; color: #666; margin-bottom: 10px;">${question.year}å¹´ ${question.season}è€ƒé¡Œ</div>` : '';
            
            return `
                <div class="question">
                    <div class="question-number">å•é¡Œ ${index + 1}</div>
                    ${yearInfo}
                    <div class="question-text">${question.question}</div>
                    <div class="question-text">${question.sentence}</div>
                    <div class="options">
                        ${optionsHTML}
                    </div>
                </div>
            `;
        }

        // ç”Ÿæˆå¥å­é‡çµ„é¡Œå‹
        function generateReorderQuestion(question, index) {
            let optionsHTML = '';
            
            question.options.forEach((option, i) => {
                const isSelected = userAnswers[index] === i;
                const isCorrect = isAnswered[index] && i === question.correctAnswer;
                const isIncorrect = isAnswered[index] && isSelected && i !== question.correctAnswer;
                
                let optionClass = 'option';
                if (isSelected) optionClass += ' selected';
                if (isCorrect) optionClass += ' correct';
                if (isIncorrect) optionClass += ' incorrect';
                
                optionsHTML += `
                    <div class="${optionClass}" onclick="window.selectOption(${i})">
                        ${option.text}
                    </div>
                `;
            });
            
            // å¦‚æœæ˜¯æ­·å±†è€ƒé¡Œï¼Œé¡¯ç¤ºå¹´ä»½è³‡è¨Š
            const yearInfo = question.year && question.season ? 
                `<div style="font-size: 14px; color: #666; margin-bottom: 10px;">${question.year}å¹´ ${question.season}è€ƒé¡Œ</div>` : '';
            
            return `
                <div class="question">
                    <div class="question-number">å•é¡Œ ${index + 1}</div>
                    ${yearInfo}
                    <div class="question-text">${question.question}</div>
                    <div class="question-text">${question.sentence}</div>
                    <div class="options">
                        ${optionsHTML}
                    </div>
                </div>
            `;
        }

        // ç”Ÿæˆé è¨­é¡Œå‹
        function generateDefaultQuestion(question, index) {
            let optionsHTML = '';
            
            question.options.forEach((option, i) => {
                const isSelected = userAnswers[index] === i;
                const isCorrect = isAnswered[index] && i === question.correctAnswer;
                const isIncorrect = isAnswered[index] && isSelected && i !== question.correctAnswer;
                
                let optionClass = 'option';
                if (isSelected) optionClass += ' selected';
                if (isCorrect) optionClass += ' correct';
                if (isIncorrect) optionClass += ' incorrect';
                
                optionsHTML += `
                    <div class="${optionClass}" onclick="window.selectOption(${i})">
                        ${option.text}
                    </div>
                `;
            });
            
            // å¦‚æœæ˜¯æ­·å±†è€ƒé¡Œï¼Œé¡¯ç¤ºå¹´ä»½è³‡è¨Š
            const yearInfo = question.year && question.season ? 
                `<div style="font-size: 14px; color: #666; margin-bottom: 10px;">${question.year}å¹´ ${question.season}è€ƒé¡Œ</div>` : '';
            
            return `
                <div class="question">
                    <div class="question-number">å•é¡Œ ${index + 1}</div>
                    ${yearInfo}
                    <div class="question-text">${question.question}</div>
                    <div class="options">
                        ${optionsHTML}
                    </div>
                </div>
            `;
        }

        // é¸æ“‡é¸é … (è¨­ç‚ºå…¨åŸŸå‡½æ•¸)
        window.selectOption = function(optionIndex) {
            if (isAnswered[currentQuestionIndex]) return;
            
            userAnswers[currentQuestionIndex] = optionIndex;
            isAnswered[currentQuestionIndex] = true;
            
            // æª¢æŸ¥ç­”æ¡ˆ
            const question = shuffledQuestions[currentQuestionIndex];
            if (optionIndex === question.correctAnswer) {
                score++;
            } else {
                // è¨˜éŒ„éŒ¯èª¤é¡Œç›®
                if (!wrongQuestions.includes(question.id)) {
                    wrongQuestions.push(question.id);
                }
            }
            
            updateScore();
            displayQuestion(currentQuestionIndex);
            updateButtons();
        };

        // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
        function updateButtons() {
            prevBtn.disabled = currentQuestionIndex === 0;
            
            if (currentQuestionIndex === shuffledQuestions.length - 1) {
                nextBtn.style.display = 'none';
                submitBtn.style.display = 'inline-block';
            } else {
                nextBtn.style.display = 'inline-block';
                submitBtn.style.display = 'none';
            }
        }

        // æ›´æ–°é€²åº¦
        function updateProgress() {
            progressElement.textContent = `ç¬¬ ${currentQuestionIndex + 1} é¡Œ / å…± ${shuffledQuestions.length} é¡Œ`;
        }

        // æ›´æ–°åˆ†æ•¸
        function updateScore() {
            const answeredCount = isAnswered.filter(Boolean).length;
            scoreElement.textContent = `å¾—åˆ†: ${score}/${answeredCount}`;
        }

        // é¡¯ç¤ºæ¸¬é©—çµæœ
        function showResults() {
            // è¨ˆç®—å„é¡Œå‹çš„éŒ¯èª¤æ•¸é‡
            const errorTypes = {
                reading: 0,
                writing: 0,
                vocabulary: 0,
                synonym: 0,
                grammar: 0,
                reorder: 0
            };
            
            wrongQuestions.forEach(questionId => {
                // å…ˆå¾ä¸€èˆ¬é¡Œåº«æ‰¾ï¼Œå†å¾æ­·å±†è€ƒé¡Œåº«æ‰¾
                let question = window.questionBank.find(q => q.id === questionId);
                if (!question) {
                    question = window.pastQuestionBank.find(q => q.id === questionId);
                }
                if (question && errorTypes.hasOwnProperty(question.type)) {
                    errorTypes[question.type]++;
                }
            });
            
            let resultHTML = `
                <div class="result-title">æ¸¬é©—å®Œæˆï¼</div>
                <div>æœ€çµ‚å¾—åˆ†: ${score}/${shuffledQuestions.length}</div>
                <div>ç”¨æ™‚: ${formatTime(elapsedTime)}</div>
                <div class="wrong-questions">
                    <div class="wrong-title">å„é¡Œå‹éŒ¯èª¤åˆ†æï¼š</div>
                    <ul>
                        <li>æ¼¢å­—è®€éŸ³éŒ¯èª¤: ${errorTypes.reading}</li>
                        <li>æ¼¢å­—æ›¸å¯«éŒ¯èª¤: ${errorTypes.writing}</li>
                        <li>è©èªå¡«ç©ºéŒ¯èª¤: ${errorTypes.vocabulary}</li>
                        <li>è¿‘ç¾©è©æ›¿æ›éŒ¯èª¤: ${errorTypes.synonym}</li>
                        <li>æ–‡æ³•é¸æ“‡éŒ¯èª¤: ${errorTypes.grammar}</li>
                        <li>å¥å­é‡çµ„éŒ¯èª¤: ${errorTypes.reorder}</li>
                    </ul>
                </div>
            `;
            
            if (wrongQuestions.length > 0) {
                resultHTML += `
                    <div class="wrong-questions">
                        <div class="wrong-title">éŒ¯èª¤é¡Œç›®:</div>
                        <ul>
                `;
                
                wrongQuestions.forEach(questionId => {
                    // å…ˆå¾ä¸€èˆ¬é¡Œåº«æ‰¾ï¼Œå†å¾æ­·å±†è€ƒé¡Œåº«æ‰¾
                    let originalQuestion = window.questionBank.find(q => q.id === questionId);
                    if (!originalQuestion) {
                        originalQuestion = window.pastQuestionBank.find(q => q.id === questionId);
                    }
                    
                    const shuffledQuestion = shuffledQuestions.find(q => q.id === questionId);
                    const userAnswerIndex = userAnswers[shuffledQuestions.indexOf(shuffledQuestion)];
                    
                    let questionText = '';
                    
                    if (originalQuestion) {
                        if (originalQuestion.type === "reading") {
                            questionText = `${originalQuestion.kanji} - æ‚¨çš„ç­”æ¡ˆ: ${shuffledQuestion.options[userAnswerIndex].text} - æ­£ç¢ºç­”æ¡ˆ: ${shuffledQuestion.options[shuffledQuestion.correctAnswer].text}`;
                        } else if (originalQuestion.type === "writing") {
                            questionText = `${originalQuestion.kana} - æ‚¨çš„ç­”æ¡ˆ: ${shuffledQuestion.options[userAnswerIndex].text} - æ­£ç¢ºç­”æ¡ˆ: ${shuffledQuestion.options[shuffledQuestion.correctAnswer].text}`;
                        } else {
                            questionText = `å•é¡Œ ${originalQuestion.id} - æ‚¨çš„ç­”æ¡ˆ: ${shuffledQuestion.options[userAnswerIndex].text} - æ­£ç¢ºç­”æ¡ˆ: ${shuffledQuestion.options[shuffledQuestion.correctAnswer].text}`;
                        }
                        
                        resultHTML += `<li>${questionText}</li>`;
                    }
                });
                
                resultHTML += `
                        </ul>
                    </div>
                `;
            } else {
                resultHTML += `<div class="success-message">æ­å–œï¼å…¨éƒ¨ç­”å°ï¼</div>`;
            }
            
            resultElement.innerHTML = resultHTML;
        }

        // åˆå§‹åŒ–æ‡‰ç”¨ç¨‹å¼
        function initApp() {
            initEventListeners();
            
            // ç›´æ¥ä½¿ç”¨å…§å»ºé¡Œåº«
            loadQuestionBank();
        }

        // å•Ÿå‹•æ‡‰ç”¨ç¨‹å¼
        initApp();
    </script>
</body>
</html>