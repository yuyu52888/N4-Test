<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#3498db">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="æ—¥æ–‡N4æ¸¬é©—">

    <!-- Icons -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ“š</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ“š</text></svg>">
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥æ–‡N4å–®å­—èˆ‡æ–‡æ³•æ¸¬é©—ç³»çµ±</title>
    <style>
    * {
        box-sizing: border-box;
        font-family: "Microsoft JhengHei", "Segoe UI", sans-serif;
    }
    body {
        background-color: #f5f5f5;
        margin: 0;
        padding: 20px;
        color: #333;
        line-height: 1.6;
    }
    .container {
        max-width: 800px;
        margin: 0 auto;
        background: white;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        padding: 25px;
        position: relative;
    }
    h1 {
        color: #2c3e50;
        text-align: center;
        margin-bottom: 30px;
        border-bottom: 2px solid #eee;
        padding-bottom: 15px;
    }
    .home-screen, .quiz-screen, .result-screen, .history-screen {
        display: none;
    }
    .home-screen.active, .quiz-screen.active, .result-screen.active, .history-screen.active {
        display: block;
    }
    .home-buttons {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-top: 30px;
    }
    .home-btn {
        padding: 15px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 18px;
        transition: background-color 0.3s;
    }
    .home-btn:hover {
        background-color: #2980b9;
    }
    .home-btn.exit {
        background-color: #e74c3c;
    }
    .home-btn.exit:hover {
        background-color: #c0392b;
    }
    .home-btn.update {
        background-color: #2ecc71;
    }
    .home-btn.update:hover {
        background-color: #27ae60;
    }
    
    /* æ¸¬é©—é¡å‹é¸æ“‡æŒ‰éˆ•æ¨£å¼ */
    .count-buttons-container {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        margin-top: 15px;
    }
    .count-btn {
        margin: 0;
        padding: 15px 10px;
        background-color: #95a5a6;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s ease;
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
    }
    .count-btn.active {
        background-color: #2ecc71;
        font-weight: bold;
        transform: scale(1.02);
        box-shadow: 0 4px 8px rgba(46, 204, 113, 0.3);
    }
    .count-btn:hover {
        background-color: #7f8c8d;
        transform: translateY(-2px);
    }
    .count-btn.active:hover {
        background-color: #27ae60;
    }
    
    /* é¡Œç›®æ•¸é‡è¼¸å…¥æ¡† */
    .question-count-input {
        margin: 20px 0;
        text-align: center;
    }
    .question-count-input label {
        display: block;
        margin-bottom: 10px;
        font-weight: bold;
        color: #2c3e50;
    }
    .question-count-input input {
        width: 100%;
        padding: 12px;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 16px;
        text-align: center;
    }
    
    .question {
        margin-bottom: 25px;
        padding: 15px;
        border-radius: 8px;
        background-color: #f9f9f9;
    }
    .question-number {
        font-weight: bold;
        color: #3498db;
        margin-bottom: 10px;
    }
    .question-text {
        font-size: 18px;
        margin-bottom: 15px;
        line-height: 1.5;
    }
    .kanji {
        font-size: 24px;
        font-weight: bold;
        color: #e74c3c;
        margin: 10px 0;
        text-align: center;
    }
    .options {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    .option {
        padding: 12px 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.2s;
    }
    .option:hover {
        background-color: #f0f0f0;
    }
    .option.selected {
        background-color: #d6eaf8;
        border-color: #3498db;
    }
    .option.correct {
        background-color: #d4edda;
        border-color: #28a745;
    }
    .option.incorrect {
        background-color: #f8d7da;
        border-color: #dc3545;
    }
    .explanation {
        margin-top: 15px;
        padding: 15px;
        background-color: #e8f4fc;
        border-radius: 5px;
        display: none;
    }
    .explanation.show {
        display: block;
    }
    .explanation-title {
        font-weight: bold;
        color: #2c3e50;
        margin-bottom: 8px;
    }
    .option-explanation {
        margin-top: 10px;
        padding: 8px;
        background-color: #f8f9fa;
        border-radius: 4px;
        font-size: 14px;
    }
    .button-container {
        display: flex;
        justify-content: center;
        margin-top: 30px;
        gap: 15px;
        flex-wrap: wrap;
    }
    button {
        padding: 12px 25px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s;
    }
    button:hover {
        background-color: #2980b9;
    }
    button:disabled {
        background-color: #bdc3c7;
        cursor: not-allowed;
    }
    button.restart {
        background-color: #e67e22;
    }
    button.restart:hover {
        background-color: #d35400;
    }
    .stats {
        text-align: center;
        margin-bottom: 20px;
        font-size: 18px;
        color: #2c3e50;
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
    }
    .timer {
        font-weight: bold;
        color: #e74c3c;
    }
    .result {
        text-align: center;
        margin-top: 20px;
        padding: 15px;
        border-radius: 8px;
        background-color: #e8f4fc;
    }
    .result-title {
        font-weight: bold;
        font-size: 20px;
        margin-bottom: 10px;
        color: #2c3e50;
    }
    .wrong-questions {
        margin-top: 20px;
        text-align: left;
    }
    .wrong-title {
        font-weight: bold;
        margin-bottom: 10px;
        color: #e74c3c;
    }
    .history-list {
        margin-top: 20px;
    }
    .history-item {
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        margin-bottom: 10px;
        background-color: #f9f9f9;
    }
    .history-date {
        font-weight: bold;
        color: #2c3e50;
    }
    .history-stats {
        display: flex;
        justify-content: space-between;
        margin-top: 10px;
        flex-wrap: wrap;
    }
    .history-stat {
        flex: 1;
        min-width: 120px;
        text-align: center;
        padding: 5px;
    }
    .question-count-selector {
        margin: 20px 0;
        text-align: center;
    }
    .loading {
        opacity: 0.6;
        pointer-events: none;
    }
    .error-message {
        background-color: #f8d7da;
        color: #721c24;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
        text-align: center;
    }
    .success-message {
        background-color: #d4edda;
        color: #155724;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
        text-align: center;
    }
    .update-indicator {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 10px;
        height: 10px;
        background-color: #2ecc71;
        border-radius: 50%;
        z-index: 1001;
        animation: pulse 2s infinite;
    }
    .update-indicator.outdated {
        background-color: #e74c3c;
    }
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
    }


.main-type-buttons {
    display: grid;
    grid-template-columns: 1fr;
    gap: 12px;
    margin-bottom: 10px;
}






/* æ–°å¢å­é¡å‹é¸æ“‡å™¨æ¨£å¼ */
/* å­é¡å‹é¸æ“‡å™¨æ¨£å¼ */
.subtype-selector {
    margin: 0 0 15px 0;
    padding: 10px;
    background-color: #f8f9fa;
    border-radius: 6px;
    border: 1px solid #e9ecef;
    width: 100%;
}

.subtype-title {
    margin-bottom: 8px;
    font-weight: bold;
    color: #2c3e50;
    text-align: center;
    font-size: 14px;
}

.subtype-buttons-container {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 6px;
}



    
    /* æ‰‹æ©Ÿç‰ˆæ¨£å¼ */
@media (max-width: 768px) {
    .subtype-buttons-container {
        grid-template-columns: repeat(2, 1fr);
    }
}


    @media (max-width: 768px) {
        .container {
            padding: 15px;
            margin: 10px;
            border-radius: 8px;
        }
        h1 {
            font-size: 24px;
            margin-bottom: 20px;
        }
        .home-btn, button {
            padding: 18px;
            font-size: 16px;
        }
        .question-text {
            font-size: 16px;
        }
        .kanji {
            font-size: 20px;
        }
        .option {
            padding: 15px;
            font-size: 16px;
            min-height: 44px;
            display: flex;
            align-items: center;
        }
        .button-container {
            flex-direction: column;
            gap: 10px;
        }
        .button-container button {
            width: 100%;
        }
        .history-stats {
            flex-direction: column;
        }
        .history-stat {
            min-width: 100%;
            text-align: left;
            margin-bottom: 5px;
        }
        .stats {
            flex-direction: column;
            gap: 10px;
        }
        .count-buttons-container {
            grid-template-columns: 1fr;
            gap: 10px;
        }
        .count-btn {
            padding: 18px 15px;
            font-size: 18px;
            min-height: 60px;
        }
        .question-count-selector p {
            font-size: 18px;
            margin-bottom: 15px;
        }
    }
    
    /* é˜²æ­¢æ‰‹æ©Ÿä¸Šé»æ“Šé«˜äº® */
    * {
        -webkit-tap-highlight-color: transparent;
    }
    /* æ”¹å–„è§¸æ‘¸é«”é©— */
    button, .option {
        touch-action: manipulation;
    }
    /* æ–°å¢é‡çµ„å¥å­é¡Œå‹çš„æ¨£å¼ */
    .sentence-with-gap {
        font-size: 20px;
        margin: 15px 0;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 8px;
        text-align: center;
        border: 2px dashed #3498db;
        line-height: 1.8;
    }
    .gap {
        color: #e74c3c;
        font-weight: bold;
        background-color: #fff;
        padding: 4px 12px;
        border-radius: 6px;
        margin: 0 8px;
        border: 2px solid #e74c3c;
        display: inline-block;
        min-width: 60px;
        text-align: center;
    }
    </style>

<!-- è¼‰å…¥åˆ†é¡å‹é¡Œåº« -->
<script src="reading.js"></script>
<script src="writing.js"></script>
<script src="vocabulary.js"></script>
<script src="synonym.js"></script>
<script src="grammar.js"></script>
<script src="reorder.js"></script>




</head>
<body>
    <div class="container">
        <div class="update-indicator" id="update-indicator"></div>
        <h1>æ—¥æ–‡æ¸¬é©—ç³»çµ±</h1>
        
        <!-- é¦–é  -->
        <div id="home-screen" class="home-screen active">
            <div class="home-buttons">
                <button id="start-quiz-btn" class="home-btn">é–‹å§‹æ¸¬é©—</button>
                <button id="update-btn" class="home-btn update">æª¢æŸ¥é¡Œåº«æ›´æ–°</button>
                
<div class="question-count-selector">
    <p>é¸æ“‡æ¸¬é©—é¡å‹ï¼š</p>
    
    <!-- ç¬¬ä¸€è¡Œï¼šä¸»è¦é¡å‹æŒ‰éˆ• -->
    <div class="main-type-buttons">
        <button id="count-past-btn" class="count-btn">æ­·å±†è€ƒé¡Œ</button>
        <button id="count-vocab-btn" class="count-btn">å–®å­—æ¸¬é©—</button>
        <button id="count-simulate-btn" class="count-btn active">æ¨¡æ“¬N4è€ƒé¡Œ</button>
    </div>
    
    <!-- ç¬¬äºŒè¡Œï¼šå­é¡å‹é¸æ“‡å™¨ï¼ˆæ”¾åœ¨æ¨¡æ“¬è€ƒé¡Œä¸‹æ–¹ï¼‰ -->
    <div id="subtype-selector" class="subtype-selector">
        <p class="subtype-title">æ¨¡æ“¬è€ƒé¡Œç´°åˆ†é¡å‹ï¼š</p>
        <div class="subtype-buttons-container">
            <button id="subtype-reading" class="subtype-btn">æ¼¢å­—è®€éŸ³</button>
            <button id="subtype-writing" class="subtype-btn">æ¼¢å­—æ›¸å¯«</button>
            <button id="subtype-vocabulary" class="subtype-btn">è©èªå¡«ç©º</button>
            <button id="subtype-synonym" class="subtype-btn">è¿‘ç¾©æ›¿æ›</button>
            <button id="subtype-grammar" class="subtype-btn">æ–‡æ³•é¸æ“‡</button>
            <button id="subtype-reorder" class="subtype-btn">å¥å­é‡çµ„</button>
        </div>
    </div>
    
    <div class="question-count-input">
        <label for="question-count">è«‹å¡«å¯«æ¸¬é©—çš„é¡Œç›®æ•¸é‡(é è¨­30é¡Œï¼Œæ¯æ¬¡æœ€å¤š100é¡Œ)ï¼š</label>
        <input type="number" id="question-count" min="1" max="100" value="30">
    </div>
</div>



                <button id="view-history-btn" class="home-btn">æ­·å²ç´€éŒ„æŸ¥è©¢</button>
                <button id="exit-btn" class="home-btn exit">çµæŸæ¸¬é©—</button>
            </div>
        </div>
        
        <!-- æ¸¬é©—é é¢ -->
        <div id="quiz-screen" class="quiz-screen">
            <div class="stats">
                <span id="progress">ç¬¬ 1 é¡Œ / å…± 10 é¡Œ</span>
                <span id="score">å¾—åˆ†: 0/0</span>
                <span id="timer" class="timer">æ™‚é–“: 00:00</span>
            </div>
            
            <div id="quiz-container">
                <!-- é¡Œç›®å°‡ç”±JavaScriptå‹•æ…‹ç”Ÿæˆ -->
            </div>
            
            <div class="button-container">
                <button id="prev-btn" disabled>ä¸Šä¸€é¡Œ</button>
                <button id="next-btn">ä¸‹ä¸€é¡Œ</button>
                <button id="submit-btn" style="display: none;">æäº¤ç­”æ¡ˆ</button>
                <button id="back-home-btn" class="restart">è¿”å›é¦–é </button>
            </div>
        </div>
        
        <!-- çµæœé é¢ -->
        <div id="result-screen" class="result-screen">
            <div id="result" class="result">
                <!-- æ¸¬é©—çµæœå°‡åœ¨é€™è£¡é¡¯ç¤º -->
            </div>
            
            <div class="button-container">
                <button id="restart-btn" class="restart">é‡æ–°é–‹å§‹æ¸¬é©—</button>
                <button id="result-back-home-btn">è¿”å›é¦–é </button>
            </div>
        </div>
        
        <!-- æ­·å²ç´€éŒ„é é¢ -->
        <div id="history-screen" class="history-screen">
            <h2>æ¸¬é©—æ­·å²ç´€éŒ„</h2>
            
            <div id="history-list" class="history-list">
                <!-- æ­·å²ç´€éŒ„å°‡åœ¨é€™è£¡é¡¯ç¤º -->
            </div>
            
            <div class="button-container">
                <button id="history-back-home-btn">è¿”å›é¦–é </button>
                <button id="clear-history-btn" class="restart">æ¸…é™¤æ­·å²ç´€éŒ„</button>
            </div>
        </div>
    </div>

    <script>
        // æ‡‰ç”¨ç‹€æ…‹
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let isAnswered = [];
        let score = 0;
        let wrongQuestions = [];
        let selectedQuestions = [];
        let shuffledQuestions = [];
        let questionCount = 30;
        let isPastQuestions = false;
        let isVocabMode = false;
        let selectedSubType = null; // æ–°å¢ï¼šè¨˜éŒ„é¸æ“‡çš„å­é¡Œå‹
        let timerInterval = null;
        let startTime = null;
        let elapsedTime = 0;
        let history = JSON.parse(localStorage.getItem('n4QuizHistory')) || [];
        
        // é¡Œåº«è³‡æ–™ (å°‡å¾å¤–éƒ¨JSæ–‡ä»¶è¼‰å…¥)
        let questionBank = [];
        let pastQuestionBank = [];
        let vocabBank = [];

        // DOMå…ƒç´ 
        const countSimulateBtn = document.getElementById('count-simulate-btn');
        const countPastBtn = document.getElementById('count-past-btn');
        const countVocabBtn = document.getElementById('count-vocab-btn');
        const questionCountInput = document.getElementById('question-count');

// æ–°å¢ï¼šå­é¡å‹æŒ‰éˆ•
const subtypeReadingBtn = document.getElementById('subtype-reading');
const subtypeWritingBtn = document.getElementById('subtype-writing');
const subtypeVocabularyBtn = document.getElementById('subtype-vocabulary');
const subtypeSynonymBtn = document.getElementById('subtype-synonym');
const subtypeGrammarBtn = document.getElementById('subtype-grammar');
const subtypeReorderBtn = document.getElementById('subtype-reorder');




        const homeScreen = document.getElementById('home-screen');
        const quizScreen = document.getElementById('quiz-screen');
        const resultScreen = document.getElementById('result-screen');
        const historyScreen = document.getElementById('history-screen');
        const updateIndicator = document.getElementById('update-indicator');
        
        const startQuizBtn = document.getElementById('start-quiz-btn');
        const viewHistoryBtn = document.getElementById('view-history-btn');
        const exitBtn = document.getElementById('exit-btn');
        const updateBtn = document.getElementById('update-btn');
        
        const quizContainer = document.getElementById('quiz-container');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const submitBtn = document.getElementById('submit-btn');
        const backHomeBtn = document.getElementById('back-home-btn');
        
        const restartBtn = document.getElementById('restart-btn');
        const resultBackHomeBtn = document.getElementById('result-back-home-btn');
        
        const historyBackHomeBtn = document.getElementById('history-back-home-btn');
        const clearHistoryBtn = document.getElementById('clear-history-btn');
        
        const progressElement = document.getElementById('progress');
        const scoreElement = document.getElementById('score');
        const timerElement = document.getElementById('timer');
        const resultElement = document.getElementById('result');
        const historyListElement = document.getElementById('history-list');

// ========== æ ¸å¿ƒåŠŸèƒ½å‡½æ•¸ ==========

function startQuiz() {
    console.log('é–‹å§‹æ¸¬é©—ï¼Œæ¨¡å¼:', isVocabMode ? 'å–®å­—æ¸¬é©—' : (isPastQuestions ? 'æ­·å±†è€ƒé¡Œ' : 'æ¨¡æ“¬N4è€ƒé¡Œ'));
    if (selectedSubType) {
        console.log('å­é¡Œå‹:', selectedSubType);
    }
    
    // é‡ç½®ç‹€æ…‹
    currentQuestionIndex = 0;
    userAnswers = [];
    isAnswered = [];
    score = 0;
    wrongQuestions = [];
    selectedQuestions = [];
    shuffledQuestions = [];
    elapsedTime = 0;

    // é¸æ“‡é¡Œåº«
    let sourceBank;
    if (isVocabMode) {
        sourceBank = vocabBank;
    } else if (isPastQuestions) {
        sourceBank = pastQuestionBank;
    } else {
        sourceBank = questionBank;
    }

    // æª¢æŸ¥é¡Œåº«æ˜¯å¦å¯ç”¨
    if (!sourceBank || sourceBank.length === 0) {
        alert('é¡Œåº«è¼‰å…¥å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦');
        return;
    }

    // æ ¹æ“šæ˜¯å¦æœ‰é¸æ“‡å­é¡Œå‹ä¾†è¨ˆç®—å¯ç”¨é¡Œç›®æ•¸é‡
    let availableQuestions;
    if (selectedSubType) {
        availableQuestions = sourceBank.filter(q => q.type === selectedSubType).length;
    } else {
        availableQuestions = sourceBank.length;
    }
    
    const actualQuestionCount = Math.min(questionCount, availableQuestions);
    
    console.log(`å¯ç”¨é¡Œç›®: ${availableQuestions}, é¸æ“‡é¡Œæ•¸: ${actualQuestionCount}`);

    // é¸æ“‡é¡Œç›®é‚è¼¯
    if (selectedSubType) {
        // å¦‚æœæœ‰é¸æ“‡å­é¡Œå‹ï¼Œåªé¸æ“‡è©²é¡å‹çš„é¡Œç›®
        selectedQuestions = selectQuestionsByType(sourceBank, selectedSubType, actualQuestionCount);
    } else if (isVocabMode || isPastQuestions) {
        // å–®å­—æ¸¬é©—æˆ–æ­·å±†è€ƒé¡Œï¼Œç›´æ¥éš¨æ©Ÿé¸æ“‡
        selectedQuestions = selectRandomQuestions(sourceBank, actualQuestionCount);
    } else {
        // æ¨¡æ“¬è€ƒé¡Œä¸”æ²’æœ‰é¸æ“‡å­é¡Œå‹ï¼Œç¢ºä¿é¡Œå‹å¹³å‡åˆ†å¸ƒ
        selectedQuestions = selectQuestionsWithBalancedTypes(sourceBank, actualQuestionCount);
    }
    
    // æª¢æŸ¥é¸æ“‡çš„é¡Œç›®æ˜¯å¦æœ‰æ•ˆ
    selectedQuestions = selectedQuestions.filter(question => isValidQuestion(question));
    
    if (selectedQuestions.length === 0) {
        alert('æ²’æœ‰æœ‰æ•ˆçš„é¡Œç›®å¯ç”¨ï¼Œè«‹æª¢æŸ¥é¡Œåº«æ ¼å¼');
        return;
    }
    
    // éš¨æ©Ÿæ‰“äº‚æ¯å€‹é¡Œç›®çš„é¸é …é †åº
    shuffledQuestions = selectedQuestions.map(question => shuffleOptions(question));
    
    userAnswers = new Array(selectedQuestions.length).fill(null);
    isAnswered = new Array(selectedQuestions.length).fill(false);
    
    console.log('æœ€çµ‚é¸æ“‡é¡Œç›®æ•¸é‡:', selectedQuestions.length);
    
    // é–‹å§‹è¨ˆæ™‚
    startTimer();
    
    // é¡¯ç¤ºæ¸¬é©—é é¢
    showScreen(quizScreen);
    displayQuestion(currentQuestionIndex);
    updateButtons();
    updateProgress();
}

// æª¢æŸ¥é¡Œç›®æ˜¯å¦æœ‰æ•ˆ
function isValidQuestion(question) {
    if (!question) return false;
    if (!question.id) return false;
    if (!question.type) return false;
    if (!question.question) return false;
    if (!question.options || !Array.isArray(question.options) || question.options.length === 0) return false;
    if (typeof question.correctAnswer !== 'number' || question.correctAnswer < 0 || question.correctAnswer >= question.options.length) return false;
    
    // æª¢æŸ¥æ¯å€‹é¸é …æ˜¯å¦æœ‰å¿…è¦çš„å±¬æ€§
    for (let option of question.options) {
        if (!option.text) return false;
        if (!option.explanation) return false;
    }
    
    return true;
}

// é¸æ“‡ç‰¹å®šé¡å‹çš„é¡Œç›®
function selectQuestionsByType(sourceBank, type, count) {
    const typeQuestions = sourceBank.filter(question => question.type === type && isValidQuestion(question));
    
    if (typeQuestions.length === 0) {
        console.error(`æ²’æœ‰æ‰¾åˆ° ${type} é¡å‹çš„æœ‰æ•ˆé¡Œç›®`);
        return [];
    }
    
    const actualCount = Math.min(count, typeQuestions.length);
    return shuffleArray([...typeQuestions]).slice(0, actualCount);
}

// éš¨æ©Ÿé¸æ“‡é¡Œç›®
function selectRandomQuestions(sourceBank, count) {
    const validQuestions = sourceBank.filter(question => isValidQuestion(question));
    
    if (validQuestions.length === 0) {
        console.error('é¡Œåº«ä¸­æ²’æœ‰æœ‰æ•ˆçš„é¡Œç›®');
        return [];
    }
    
    const actualCount = Math.min(count, validQuestions.length);
    return shuffleArray([...validQuestions]).slice(0, actualCount);
}

// é¸æ“‡é¡Œç›®ä¸¦ç¢ºä¿é¡Œå‹å¹³å‡åˆ†å¸ƒ
function selectQuestionsWithBalancedTypes(sourceBank, count) {
    // å…ˆéæ¿¾æ‰ç„¡æ•ˆçš„é¡Œç›®
    const validQuestions = sourceBank.filter(question => isValidQuestion(question));
    
    if (validQuestions.length === 0) {
        console.error('é¡Œåº«ä¸­æ²’æœ‰æœ‰æ•ˆçš„é¡Œç›®');
        return [];
    }
    
    // æŒ‰é¡Œå‹åˆ†çµ„
    const questionsByType = {};
    validQuestions.forEach(question => {
        if (!questionsByType[question.type]) {
            questionsByType[question.type] = [];
        }
        questionsByType[question.type].push(question);
    });
    
    // è¨ˆç®—æ¯ç¨®é¡Œå‹æ‡‰è©²é¸æ“‡çš„é¡Œç›®æ•¸é‡
    const types = Object.keys(questionsByType);
    const questionsPerType = Math.ceil(count / types.length);
    
    let selectedQuestions = [];
    
    // å¾æ¯ç¨®é¡Œå‹ä¸­é¸æ“‡é¡Œç›®
    types.forEach(type => {
        const availableQuestions = questionsByType[type];
        const shuffled = shuffleArray([...availableQuestions]);
        const selected = shuffled.slice(0, Math.min(questionsPerType, availableQuestions.length));
        selectedQuestions = selectedQuestions.concat(selected);
    });
    
    // å¦‚æœé¸æ“‡çš„é¡Œç›®å¤šæ–¼æ‰€éœ€ï¼Œéš¨æ©Ÿç§»é™¤å¤šé¤˜çš„é¡Œç›®
    if (selectedQuestions.length > count) {
        selectedQuestions = shuffleArray(selectedQuestions).slice(0, count);
    }
    
    // å¦‚æœé¸æ“‡çš„é¡Œç›®å°‘æ–¼æ‰€éœ€ï¼Œå¾æ‰€æœ‰é¡Œç›®ä¸­éš¨æ©Ÿè£œå……
    if (selectedQuestions.length < count) {
        const remainingCount = count - selectedQuestions.length;
        const allQuestions = shuffleArray([...validQuestions]);
        const additionalQuestions = allQuestions.filter(q => !selectedQuestions.includes(q)).slice(0, remainingCount);
        selectedQuestions = selectedQuestions.concat(additionalQuestions);
    }
    
    // æœ€å¾Œå†éš¨æ©Ÿæ‰“äº‚ä¸€æ¬¡
    return shuffleArray(selectedQuestions);
}

function setQuestionType(type) {
    if (type === 'past') {
        isPastQuestions = true;
        isVocabMode = false;
        selectedSubType = null; // é‡ç½®å­é¡Œå‹
        updateCountButtonStates('past');
        showUpdateNotification(`æ­·å±†è€ƒé¡Œæ¨¡å¼`);
    } else if (type === 'vocab') {
        isPastQuestions = false;
        isVocabMode = true;
        selectedSubType = null; // é‡ç½®å­é¡Œå‹
        updateCountButtonStates('vocab');
        showUpdateNotification(`å–®å­—æ¸¬é©—æ¨¡å¼`);
    } else {
        isPastQuestions = false;
        isVocabMode = false;
        updateCountButtonStates('simulate');
        showUpdateNotification(`æ¨¡æ“¬N4è€ƒé¡Œæ¨¡å¼`);
    }
    
    // ç§»é™¤æ‰€æœ‰å­é¡å‹æŒ‰éˆ•çš„activeé¡åˆ¥ï¼ˆç•¶é¸æ“‡å…¶ä»–ä¸»è¦é¡å‹æ™‚ï¼‰
    if (type !== 'simulate') {
        const allSubtypeBtns = document.querySelectorAll('.subtype-btn');
        allSubtypeBtns.forEach(btn => btn.classList.remove('active'));
        selectedSubType = null;
    }
    
    updateQuestionCountLimit();
}

// è¨­ç½®å­é¡Œå‹
function setSubQuestionType(subType) {
    // ç§»é™¤æ‰€æœ‰å­é¡å‹æŒ‰éˆ•çš„activeé¡åˆ¥
    const allSubtypeBtns = document.querySelectorAll('.subtype-btn');
    allSubtypeBtns.forEach(btn => btn.classList.remove('active'));
    
    // ç‚ºç•¶å‰é»æ“Šçš„æŒ‰éˆ•æ·»åŠ activeé¡åˆ¥
    const currentBtn = document.getElementById(`subtype-${subType}`);
    if (currentBtn) {
        currentBtn.classList.add('active');
    }
    
    // è¨­ç½®ç‚ºæ¨¡æ“¬è€ƒé¡Œæ¨¡å¼
    setQuestionType('simulate');
    
    // è¨˜éŒ„é¸æ“‡çš„å­é¡Œå‹
    selectedSubType = subType;
    
    // æ›´æ–°é¡Œç›®æ•¸é‡é™åˆ¶
    updateQuestionCountLimit();
    
    console.log(`é¸æ“‡äº†å­é¡Œå‹: ${subType}`);
    showUpdateNotification(`é¸æ“‡äº† ${getSubTypeName(subType)} é¡Œå‹`);
}

// ç²å–å­é¡Œå‹ä¸­æ–‡åç¨±
function getSubTypeName(subType) {
    const typeNames = {
        'reading': 'æ¼¢å­—è®€éŸ³',
        'writing': 'æ¼¢å­—æ›¸å¯«',
        'vocabulary': 'è©èªå¡«ç©º',
        'synonym': 'è¿‘ç¾©æ›¿æ›',
        'grammar': 'æ–‡æ³•é¸æ“‡',
        'reorder': 'å¥å­é‡çµ„'
    };
    return typeNames[subType] || subType;
}

// æ›´æ–°é¡Œç›®æ•¸é‡é™åˆ¶
function updateQuestionCountLimit() {
    let maxQuestions = 0;
    
    if (isVocabMode) {
        maxQuestions = vocabBank.length;
    } else if (isPastQuestions) {
        maxQuestions = pastQuestionBank.length;
    } else {
        // æ¨¡æ“¬è€ƒé¡Œï¼šå¦‚æœæœ‰é¸æ“‡å­é¡Œå‹ï¼Œåªè¨ˆç®—è©²å­é¡Œå‹çš„é¡Œç›®æ•¸é‡
        if (selectedSubType) {
            // å¾å·²åˆä½µçš„ questionBank ä¸­éæ¿¾è©²é¡å‹çš„é¡Œç›®
            const typeQuestions = questionBank.filter(q => q.type === selectedSubType);
            maxQuestions = typeQuestions.length;
        } else {
            maxQuestions = questionBank.length;
        }
    }
    questionCountInput.max = maxQuestions;
    questionCountInput.placeholder = `æœ€å¤šå¯é¸ ${maxQuestions} é¡Œ`;
    
    if (questionCountInput.value > maxQuestions) {
        questionCountInput.value = maxQuestions;
    }
}

function updateCountButtonStates(selectedType) {
    countSimulateBtn.classList.remove('active');
    countPastBtn.classList.remove('active');
    countVocabBtn.classList.remove('active');
    
    switch(selectedType) {
        case 'simulate':
            countSimulateBtn.classList.add('active');
            break;
        case 'past':
            countPastBtn.classList.add('active');
            break;
        case 'vocab':
            countVocabBtn.classList.add('active');
            break;
    }
}
        // ========== äº‹ä»¶ç›£è½å™¨ ==========

function initEventListeners() {
    startQuizBtn.addEventListener('click', () => {
        // å¾è¼¸å…¥æ¡†ç²å–é¡Œç›®æ•¸é‡
        questionCount = parseInt(questionCountInput.value) || 30;
        
        // æª¢æŸ¥é¡Œç›®æ•¸é‡æ˜¯å¦æœ‰æ•ˆï¼ˆä½¿ç”¨æ–°çš„é‚è¼¯ï¼‰
        let maxQuestions = parseInt(questionCountInput.max) || 0;
        
        if (questionCount < 1) {
            alert('é¡Œç›®æ•¸é‡å¿…é ˆå¤§æ–¼0');
            return;
        }
        
        if (questionCount > maxQuestions) {
            alert(`é¡Œç›®æ•¸é‡ä¸èƒ½è¶…éé¡Œåº«ç¸½æ•¸ (${maxQuestions})`);
            questionCountInput.value = maxQuestions;
            questionCount = maxQuestions;
        }
        
        startQuiz();
    });
    
    viewHistoryBtn.addEventListener('click', showHistory);
    exitBtn.addEventListener('click', exitApp);
    updateBtn.addEventListener('click', checkForUpdates);
    
    countSimulateBtn.addEventListener('click', () => setQuestionType('simulate'));
    countPastBtn.addEventListener('click', () => setQuestionType('past'));
    countVocabBtn.addEventListener('click', () => setQuestionType('vocab'));

    // æ–°å¢ï¼šå­é¡å‹æŒ‰éˆ•çš„äº‹ä»¶ç›£è½å™¨
    document.getElementById('subtype-reading').addEventListener('click', () => setSubQuestionType('reading'));
    document.getElementById('subtype-writing').addEventListener('click', () => setSubQuestionType('writing'));
    document.getElementById('subtype-vocabulary').addEventListener('click', () => setSubQuestionType('vocabulary'));
    document.getElementById('subtype-synonym').addEventListener('click', () => setSubQuestionType('synonym'));
    document.getElementById('subtype-grammar').addEventListener('click', () => setSubQuestionType('grammar'));
    document.getElementById('subtype-reorder').addEventListener('click', () => setSubQuestionType('reorder'));
    
    prevBtn.addEventListener('click', prevQuestion);
    nextBtn.addEventListener('click', nextQuestion);
    submitBtn.addEventListener('click', submitQuiz);
    backHomeBtn.addEventListener('click', backToHome);
    
    restartBtn.addEventListener('click', restartQuiz);
    resultBackHomeBtn.addEventListener('click', backToHome);
    
    historyBackHomeBtn.addEventListener('click', backToHome);
    clearHistoryBtn.addEventListener('click', clearHistory);
}

        // ========== æ¸¬é©—æµç¨‹å‡½æ•¸ ==========

        function displayQuestion(index) {
            const question = shuffledQuestions[index];
            
            // æª¢æŸ¥é¡Œç›®æ˜¯å¦æœ‰æ•ˆ
            if (!isValidQuestion(question)) {
                quizContainer.innerHTML = `
                    <div class="error-message">
                        é¡Œç›®è³‡æ–™æ ¼å¼éŒ¯èª¤ï¼Œç„¡æ³•é¡¯ç¤ºæ­¤é¡Œç›®ã€‚
                    </div>
                `;
                return;
            }
            
            let questionHTML = '';
            
            switch(question.type) {
                case "reading":
                    questionHTML = generateReadingQuestion(question, index);
                    break;
                case "writing":
                    questionHTML = generateWritingQuestion(question, index);
                    break;
                case "vocabulary":
                    questionHTML = generateVocabularyQuestion(question, index);
                    break;
                case "synonym":
                    questionHTML = generateSynonymQuestion(question, index);
                    break;
                case "grammar":
                    questionHTML = generateGrammarQuestion(question, index);
                    break;
                case "reorder":  // æ–°å¢reorderé¡å‹çš„è™•ç†
                    questionHTML = generateReorderQuestion(question, index);
                    break;
                default:
                    questionHTML = generateDefaultQuestion(question, index);
            }
            
            const explanationClass = isAnswered[index] ? 'explanation show' : 'explanation';
            const correctAnswerExplanation = question.options[question.correctAnswer]?.explanation || 'æ­¤é¡Œç›®æ²’æœ‰æä¾›è§£èªª';
            
            questionHTML += `
                <div class="${explanationClass}">
                    <div class="explanation-title">è§£èªªï¼š</div>
                    ${isAnswered[index] ? generateOptionExplanations(question) : correctAnswerExplanation}
                </div>
            `;
            
            quizContainer.innerHTML = questionHTML;
        }

        function generateReorderQuestion(question, index) {
            // å¦‚æœæœ‰sentenceå±¬æ€§ï¼Œé¡¯ç¤ºå®Œæ•´çš„å¥å­
            let sentenceContent = '';
            if (question.sentence) {
                // ä½¿ç”¨æ­£è¦è¡¨é”å¼æ›¿æ›æ‰€æœ‰çš„ â˜…
                const formattedSentence = question.sentence.replace(/â˜…/g, '<span class="gap">â˜…</span>');
                sentenceContent = `<div class="sentence-with-gap">${formattedSentence}</div>`;
            } else {
                // å¦‚æœæ²’æœ‰sentenceï¼Œé¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
                sentenceContent = `<div class="error-message">é¡Œç›®ç¼ºå°‘å¥å­å…§å®¹</div>`;
            }
            
            return generateQuestionHTML(question, index, sentenceContent);
        }


function generateReadingQuestion(question, index) {
    const kanjiContent = question.kanji ? `<div class="kanji">${question.kanji}</div>` : '';
    return generateQuestionHTML(question, index, kanjiContent);
}

function generateWritingQuestion(question, index) {
    const kanaContent = question.kana ? `<div class="kanji">${question.kana}</div>` : '';
    return generateQuestionHTML(question, index, kanaContent);
}

function generateVocabularyQuestion(question, index) {
    const sentenceContent = question.sentence ? `<div class="question-text">${question.sentence}</div>` : '';
    return generateQuestionHTML(question, index, sentenceContent);
}

function generateSynonymQuestion(question, index) {
    const sentenceContent = question.sentence ? `<div class="question-text">${question.sentence}</div>` : '';
    return generateQuestionHTML(question, index, sentenceContent);
}

function generateGrammarQuestion(question, index) {
    const sentenceContent = question.sentence ? `<div class="question-text">${question.sentence}</div>` : '';
    return generateQuestionHTML(question, index, sentenceContent);
}

function generateDefaultQuestion(question, index) {
    return generateQuestionHTML(question, index, '');
}



        function generateQuestionHTML(question, index, extraContent) {
            let optionsHTML = '';
            const yearInfo = question.year && question.season ? 
                `<div style="font-size: 14px; color: #666; margin-bottom: 10px;">${question.year}å¹´ ${question.season}è€ƒé¡Œ</div>` : '';

            // å°æ–¼reorderé¡å‹çš„é¡Œç›®ï¼Œé¡¯ç¤ºä¸åŒçš„æç¤ºæ–‡å­—
            let questionText = question.question || 'é¡Œç›®å…§å®¹ç¼ºå¤±';
            if (question.type === "reorder") {
                questionText = "è«‹é¸æ“‡æœ€é©åˆå¡«å…¥ â˜… ä½ç½®çš„é¸é …ï¼š";
            }
            
            question.options.forEach((option, i) => {
                const isSelected = userAnswers[index] === i;
                const isCorrect = isAnswered[index] && i === question.correctAnswer;
                const isIncorrect = isAnswered[index] && isSelected && i !== question.correctAnswer;
                
                let optionClass = 'option';
                if (isSelected) optionClass += ' selected';
                if (isCorrect) optionClass += ' correct';
                if (isIncorrect) optionClass += ' incorrect';
                
                const optionText = option.text || 'é¸é …å…§å®¹ç¼ºå¤±';
                
                optionsHTML += `
                    <div class="${optionClass}" onclick="selectOption(${i})">
                        ${optionText}
                    </div>
                `;
            });
            
            return `
                <div class="question">
                    <div class="question-number">å•é¡Œ ${index + 1}</div>
                    ${yearInfo}
                    <div class="question-text">${questionText}</div>
                    ${extraContent}
                    <div class="options">
                        ${optionsHTML}
                    </div>
                </div>
            `;
        }


        function generateOptionExplanations(question) {
            let explanationsHTML = '';
            
            question.options.forEach((option, i) => {
                const isCorrect = i === question.correctAnswer;
                const isSelected = userAnswers[currentQuestionIndex] === i;
                
                const optionText = option.text || 'é¸é …å…§å®¹ç¼ºå¤±';
                const explanationText = option.explanation || 'æ­¤é¸é …æ²’æœ‰æä¾›è§£èªª';
                
                explanationsHTML += `
                    <div class="option-explanation" style="${isCorrect ? 'border-left: 4px solid #28a745;' : isSelected ? 'border-left: 4px solid #dc3545;' : ''}">
                        <strong>é¸é … ${i+1}: ${optionText}</strong><br>
                        ${explanationText}
                    </div>
                `;
            });
            
            return explanationsHTML;
        }

        function selectOption(optionIndex) {
            if (isAnswered[currentQuestionIndex]) return;
            
            userAnswers[currentQuestionIndex] = optionIndex;
            isAnswered[currentQuestionIndex] = true;
            
            const question = shuffledQuestions[currentQuestionIndex];
            if (optionIndex === question.correctAnswer) {
                score++;
            } else {
                if (!wrongQuestions.includes(question.id)) {
                    wrongQuestions.push(question.id);
                }
            }
            
            updateScore();
            displayQuestion(currentQuestionIndex);
            updateButtons();
        }

        function updateButtons() {
            prevBtn.disabled = currentQuestionIndex === 0;
            
            if (currentQuestionIndex === shuffledQuestions.length - 1) {
                nextBtn.style.display = 'none';
                submitBtn.style.display = 'inline-block';
            } else {
                nextBtn.style.display = 'inline-block';
                submitBtn.style.display = 'none';
            }
        }

        function updateProgress() {
            progressElement.textContent = `ç¬¬ ${currentQuestionIndex + 1} é¡Œ / å…± ${shuffledQuestions.length} é¡Œ`;
        }

        function updateScore() {
            const answeredCount = isAnswered.filter(Boolean).length;
            scoreElement.textContent = `å¾—åˆ†: ${score}/${answeredCount}`;
        }

        function nextQuestion() {
            if (currentQuestionIndex < shuffledQuestions.length - 1) {
                currentQuestionIndex++;
                displayQuestion(currentQuestionIndex);
                updateButtons();
                updateProgress();
            }
        }

        function prevQuestion() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                displayQuestion(currentQuestionIndex);
                updateButtons();
                updateProgress();
            }
        }

        function submitQuiz() {
            stopTimer();
            saveHistory();
            showResults();
            showScreen(resultScreen);
        }

        function showResults() {
            const errorTypes = {
                reading: 0,
                writing: 0,
                vocabulary: 0,
                synonym: 0,
                grammar: 0,
                reorder: 0  
            };
            
            wrongQuestions.forEach(questionId => {
                let question = questionBank.find(q => q.id === questionId) || 
                              pastQuestionBank.find(q => q.id === questionId) ||
                              vocabBank.find(q => q.id === questionId);
                if (question && errorTypes.hasOwnProperty(question.type)) {
                    errorTypes[question.type]++;
                }
            });
            
            let resultHTML = `
                <div class="result-title">æ¸¬é©—å®Œæˆï¼</div>
                <div>æœ€çµ‚å¾—åˆ†: ${score}/${shuffledQuestions.length}</div>
                <div>ç”¨æ™‚: ${formatTime(elapsedTime)}</div>
                <div class="wrong-questions">
                    <div class="wrong-title">å„é¡Œå‹éŒ¯èª¤åˆ†æï¼š</div>
                    <ul>
                        <li>æ¼¢å­—è®€éŸ³éŒ¯èª¤: ${errorTypes.reading}</li>
                        <li>æ¼¢å­—æ›¸å¯«éŒ¯èª¤: ${errorTypes.writing}</li>
                        <li>è©èªå¡«ç©ºéŒ¯èª¤: ${errorTypes.vocabulary}</li>
                        <li>è¿‘ç¾©è©æ›¿æ›éŒ¯èª¤: ${errorTypes.synonym}</li>
                        <li>æ–‡æ³•é¸æ“‡éŒ¯èª¤: ${errorTypes.grammar}</li>
                        <li>å¥å­é‡çµ„éŒ¯èª¤: ${errorTypes.reorder}</li>
                    </ul>
                </div>
            `;
            
            if (wrongQuestions.length > 0) {
                resultHTML += `
                    <div class="wrong-questions">
                        <div class="wrong-title">éŒ¯èª¤é¡Œç›®:</div>
                        <ul>
                `;
                
                wrongQuestions.forEach(questionId => {
                    let originalQuestion = questionBank.find(q => q.id === questionId) || 
                                         pastQuestionBank.find(q => q.id === questionId) ||
                                         vocabBank.find(q => q.id === questionId);
                    
                    const shuffledQuestion = shuffledQuestions.find(q => q.id === questionId);
                    const userAnswerIndex = userAnswers[shuffledQuestions.indexOf(shuffledQuestion)];
                    
                    if (originalQuestion && shuffledQuestion) {
                        let questionText = '';
                        if (originalQuestion.type === "reading") {
                            questionText = `${originalQuestion.kanji || 'é¡Œç›®å…§å®¹ç¼ºå¤±'} - æ‚¨çš„ç­”æ¡ˆ: ${shuffledQuestion.options[userAnswerIndex]?.text || 'ç­”æ¡ˆç¼ºå¤±'} - æ­£ç¢ºç­”æ¡ˆ: ${shuffledQuestion.options[shuffledQuestion.correctAnswer]?.text || 'ç­”æ¡ˆç¼ºå¤±'}`;
                        } else if (originalQuestion.type === "writing") {
                            questionText = `${originalQuestion.kana || 'é¡Œç›®å…§å®¹ç¼ºå¤±'} - æ‚¨çš„ç­”æ¡ˆ: ${shuffledQuestion.options[userAnswerIndex]?.text || 'ç­”æ¡ˆç¼ºå¤±'} - æ­£ç¢ºç­”æ¡ˆ: ${shuffledQuestion.options[shuffledQuestion.correctAnswer]?.text || 'ç­”æ¡ˆç¼ºå¤±'}`;
                        } else {
                            questionText = `å•é¡Œ ${originalQuestion.id} - æ‚¨çš„ç­”æ¡ˆ: ${shuffledQuestion.options[userAnswerIndex]?.text || 'ç­”æ¡ˆç¼ºå¤±'} - æ­£ç¢ºç­”æ¡ˆ: ${shuffledQuestion.options[shuffledQuestion.correctAnswer]?.text || 'ç­”æ¡ˆç¼ºå¤±'}`;
                        }
                        
                        resultHTML += `<li>${questionText}</li>`;
                    }
                });
                
                resultHTML += `
                        </ul>
                    </div>
                `;
            } else {
                resultHTML += `<div class="success-message">æ­å–œï¼å…¨éƒ¨ç­”å°ï¼</div>`;
            }
            
            resultElement.innerHTML = resultHTML;
        }

        // ========== å·¥å…·å‡½æ•¸ ==========

        function startTimer() {
            startTime = new Date();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            const now = new Date();
            elapsedTime = Math.floor((now - startTime) / 1000);
            
            const minutes = Math.floor(elapsedTime / 60);
            const seconds = elapsedTime % 60;
            
            timerElement.textContent = `æ™‚é–“: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function shuffleOptions(question) {
            const optionsWithIndex = question.options.map((option, index) => ({...option, originalIndex: index}));
            const shuffledOptions = shuffleArray(optionsWithIndex);
            
            const newCorrectAnswerIndex = shuffledOptions.findIndex(option => option.originalIndex === question.correctAnswer);
            
            return {
                ...question,
                options: shuffledOptions.map(option => ({text: option.text, explanation: option.explanation})),
                correctAnswer: newCorrectAnswerIndex
            };
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function showScreen(screen) {
            homeScreen.classList.remove('active');
            quizScreen.classList.remove('active');
            resultScreen.classList.remove('active');
            historyScreen.classList.remove('active');
            
            screen.classList.add('active');
        }

        function backToHome() {
            stopTimer();
            showScreen(homeScreen);
        }

        function restartQuiz() {
            backToHome();
            setTimeout(() => startQuiz(), 100);
        }

        function showHistory() {
            historyListElement.innerHTML = '';
            
            if (history.length === 0) {
                historyListElement.innerHTML = '<p>å°šç„¡æ¸¬é©—ç´€éŒ„</p>';
            } else {
                history.forEach((record, index) => {
                    const historyItem = document.createElement('div');
                    historyItem.className = 'history-item';
                    
                    const date = new Date(record.date);
                    const formattedDate = `${date.getFullYear()}/${(date.getMonth()+1).toString().padStart(2, '0')}/${date.getDate().toString().padStart(2, '0')} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
                    
                    historyItem.innerHTML = `
                        <div class="history-date">${formattedDate} - ${record.mode}</div>
                        <div class="history-stats">
                            <div class="history-stat">å¾—åˆ†: ${record.score}/${record.total}</div>
                            <div class="history-stat">æ­£ç¢ºç‡: ${Math.round((record.score / record.total) * 100)}%</div>
                            <div class="history-stat">ç”¨æ™‚: ${record.time}</div>
                        </div>
                    `;
                    
                    historyListElement.appendChild(historyItem);
                });
            }
            
            showScreen(historyScreen);
        }

        function saveHistory() {
            const record = {
                date: new Date().toISOString(),
                score: score,
                total: shuffledQuestions.length,
                time: formatTime(elapsedTime),
                mode: isVocabMode ? 'å–®å­—æ¸¬é©—' : (isPastQuestions ? 'æ­·å±†è€ƒé¡Œ' : 'æ¨¡æ“¬N4è€ƒé¡Œ')
            };
            
            history.unshift(record);
            
            if (history.length > 50) {
                history = history.slice(0, 50);
            }
            
            localStorage.setItem('n4QuizHistory', JSON.stringify(history));
        }

        function clearHistory() {
            if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰æ¸¬é©—ç´€éŒ„å—ï¼Ÿ')) {
                history = [];
                localStorage.removeItem('n4QuizHistory');
                showHistory();
            }
        }

        function exitApp() {
            if (confirm('ç¢ºå®šè¦çµæŸæ¸¬é©—å—ï¼Ÿ')) {
                // å¦‚æœæ˜¯PWAï¼Œé—œé–‰æ‡‰ç”¨
                if (window.navigator.standalone) {
                    window.close();
                } else {
                    alert('æ¸¬é©—å·²çµæŸï¼Œæ‚¨å¯ä»¥é—œé–‰æ­¤é é¢');
                }
            }
        }

        function showUpdateNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'success-message';
            notification.textContent = message;
            notification.style.position = 'fixed';
            notification.style.top = '20px';
            notification.style.left = '50%';
            notification.style.transform = 'translateX(-50%)';
            notification.style.zIndex = '1000';
            notification.style.maxWidth = '80%';
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 2000);
        }

// ========== é¡Œåº«è¼‰å…¥èˆ‡æ›´æ–° ==========

function loadQuestionBanks() {
    console.log('é–‹å§‹è¼‰å…¥é¡Œåº«...');
    
    // åˆä½µæ‰€æœ‰æ¨¡æ“¬è€ƒé¡Œåº«ï¼ˆé€™äº›æ˜¯ç›´æ¥é€é <script> è¼‰å…¥çš„ï¼‰
    try {
        questionBank = [];
        
        // é€ä¸€æª¢æŸ¥ä¸¦åˆä½µ6å€‹åˆ†é¡é¡Œåº«
        const typeQuestions = [
            { name: 'reading', var: readingQuestions },
            { name: 'writing', var: writingQuestions },
            { name: 'vocabulary', var: vocabularyQuestions },
            { name: 'synonym', var: synonymQuestions },
            { name: 'grammar', var: grammarQuestions },
            { name: 'reorder', var: reorderQuestions }
        ];
        
        typeQuestions.forEach(type => {
            if (typeof type.var !== 'undefined') {
                questionBank = questionBank.concat(type.var);
                console.log(`âœ… ${type.name} é¡Œåº«è¼‰å…¥æˆåŠŸ: ${type.var.length} é¡Œ`);
            } else {
                console.warn(`âš ï¸ ${type.name} é¡Œåº«æœªè¼‰å…¥`);
            }
        });
        
        console.log('æ¨¡æ“¬N4è€ƒé¡Œé¡Œåº«åˆä½µå®Œæˆï¼Œç¸½é¡Œç›®æ•¸é‡:', questionBank.length);
        
    } catch (error) {
        console.error('è¼‰å…¥æ¨¡æ“¬è€ƒé¡Œåº«æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
        questionBank = [];
    }
    
// è¼‰å…¥æ­·å±†è€ƒé¡Œï¼ˆæª¢æŸ¥æ‰€æœ‰å¯èƒ½çš„è®Šæ•¸åç¨±ï¼‰
if (typeof window.pastQuestionBank !== 'undefined' && window.pastQuestionBank.length > 0) {
    pastQuestionBank = window.pastQuestionBank;
    console.log('âœ… æ­·å±†è€ƒé¡Œé¡Œåº«è¼‰å…¥æˆåŠŸ (window)ï¼Œé¡Œç›®æ•¸é‡:', pastQuestionBank.length);
} else if (typeof pastQuestionBank !== 'undefined' && pastQuestionBank.length > 0) {
    // å¦‚æœç›´æ¥æœ‰å…¨åŸŸè®Šæ•¸
    console.log('âœ… æ­·å±†è€ƒé¡Œé¡Œåº«è¼‰å…¥æˆåŠŸ (global)ï¼Œé¡Œç›®æ•¸é‡:', pastQuestionBank.length);
} else {
    console.warn('âš ï¸ æ­·å±†è€ƒé¡Œé¡Œåº«æœªè¼‰å…¥æˆ–ç‚ºç©ºï¼Œå˜—è©¦å‹•æ…‹è¼‰å…¥...');
    pastQuestionBank = [];
    
    // å˜—è©¦å‹•æ…‹è¼‰å…¥
    loadScript('pastQuestionBank.js', () => {
        // è¼‰å…¥å¾Œå†æ¬¡æª¢æŸ¥æ‰€æœ‰å¯èƒ½çš„è®Šæ•¸åç¨±
        setTimeout(() => {
            if (typeof window.pastQuestionBank !== 'undefined' && window.pastQuestionBank.length > 0) {
                pastQuestionBank = window.pastQuestionBank;
                console.log('âœ… æ­·å±†è€ƒé¡Œé¡Œåº«å‹•æ…‹è¼‰å…¥æˆåŠŸ (window)ï¼Œé¡Œç›®æ•¸é‡:', pastQuestionBank.length);
            } else if (typeof pastQuestionBank !== 'undefined' && pastQuestionBank.length > 0) {
                console.log('âœ… æ­·å±†è€ƒé¡Œé¡Œåº«å‹•æ…‹è¼‰å…¥æˆåŠŸ (global)ï¼Œé¡Œç›®æ•¸é‡:', pastQuestionBank.length);
            } else {
                console.error('âŒ æ­·å±†è€ƒé¡Œé¡Œåº«å‹•æ…‹è¼‰å…¥å¤±æ•—æˆ–ç‚ºç©ºé™£åˆ—');
            }
            updateQuestionCountLimit(); // æ›´æ–°é¡Œç›®æ•¸é‡é™åˆ¶
        }, 100);
    });
}

// è¼‰å…¥å–®å­—æ¸¬é©—é¡Œåº«ï¼ˆæª¢æŸ¥æ‰€æœ‰å¯èƒ½çš„è®Šæ•¸åç¨±ï¼‰
if (typeof window.vocabBank !== 'undefined' && window.vocabBank.length > 0) {
    vocabBank = window.vocabBank;
    console.log('âœ… å–®å­—æ¸¬é©—é¡Œåº«è¼‰å…¥æˆåŠŸ (window)ï¼Œé¡Œç›®æ•¸é‡:', vocabBank.length);
} else if (typeof vocabBank !== 'undefined' && vocabBank.length > 0) {
    // å¦‚æœç›´æ¥æœ‰å…¨åŸŸè®Šæ•¸
    console.log('âœ… å–®å­—æ¸¬é©—é¡Œåº«è¼‰å…¥æˆåŠŸ (global)ï¼Œé¡Œç›®æ•¸é‡:', vocabBank.length);
} else {
    console.warn('âš ï¸ å–®å­—æ¸¬é©—é¡Œåº«æœªè¼‰å…¥æˆ–ç‚ºç©ºï¼Œå˜—è©¦å‹•æ…‹è¼‰å…¥...');
    vocabBank = [];
    
    // å˜—è©¦å‹•æ…‹è¼‰å…¥
    loadScript('vocab_bank.js', () => {
        // è¼‰å…¥å¾Œå†æ¬¡æª¢æŸ¥æ‰€æœ‰å¯èƒ½çš„è®Šæ•¸åç¨±
        setTimeout(() => {
            if (typeof window.vocabBank !== 'undefined' && window.vocabBank.length > 0) {
                vocabBank = window.vocabBank;
                console.log('âœ… å–®å­—æ¸¬é©—é¡Œåº«å‹•æ…‹è¼‰å…¥æˆåŠŸ (window)ï¼Œé¡Œç›®æ•¸é‡:', vocabBank.length);
            } else if (typeof vocabBank !== 'undefined' && vocabBank.length > 0) {
                console.log('âœ… å–®å­—æ¸¬é©—é¡Œåº«å‹•æ…‹è¼‰å…¥æˆåŠŸ (global)ï¼Œé¡Œç›®æ•¸é‡:', vocabBank.length);
            } else {
                console.error('âŒ å–®å­—æ¸¬é©—é¡Œåº«å‹•æ…‹è¼‰å…¥å¤±æ•—æˆ–ç‚ºç©ºé™£åˆ—');
            }
            updateQuestionCountLimit(); // æ›´æ–°é¡Œç›®æ•¸é‡é™åˆ¶
        }, 100);
    });
}
 
    // æª¢æŸ¥æœ€çµ‚é¡Œåº«ç‹€æ…‹
    setTimeout(() => {
        console.log('=== æœ€çµ‚é¡Œåº«è¼‰å…¥ç‹€æ…‹ ===');
        console.log('æ¨¡æ“¬è€ƒé¡Œåº«:', questionBank.length, 'é¡Œ');
        console.log('æ­·å±†è€ƒé¡Œåº«:', pastQuestionBank.length, 'é¡Œ');
        console.log('å–®å­—æ¸¬é©—é¡Œåº«:', vocabBank.length, 'é¡Œ');
        
        if (questionBank.length === 0) {
            console.error('âŒ æ¨¡æ“¬è€ƒé¡Œåº«è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥6å€‹åˆ†é¡é¡Œåº«æª”æ¡ˆ');
        }
    }, 1000);
}

function loadScript(src, callback) {
    const script = document.createElement('script');
    script.src = src;
    script.onload = callback;
    script.onerror = () => {
        console.error(`âŒ è¼‰å…¥é¡Œåº«å¤±æ•—: ${src}`);
        callback();
    };
    document.head.appendChild(script);
}

function checkForUpdates() {
    // æ¨¡æ“¬æª¢æŸ¥æ›´æ–°
    const lastUpdate = localStorage.getItem('lastUpdateCheck');
    const now = new Date().getTime();
    
    if (lastUpdate && (now - parseInt(lastUpdate)) < 60000) {
        showUpdateNotification('å·²æ˜¯æœ€æ–°ç‰ˆæœ¬');
        return;
    }
    
    showUpdateNotification('æª¢æŸ¥æ›´æ–°ä¸­...');
    
    // æ¨¡æ“¬æ›´æ–°éç¨‹
    setTimeout(() => {
        localStorage.setItem('lastUpdateCheck', now.toString());
        showUpdateNotification('å·²æ˜¯æœ€æ–°ç‰ˆæœ¬');
    }, 1500);
}





// ========== åˆå§‹åŒ–æ‡‰ç”¨ ==========

function initApp() {
    console.log('åˆå§‹åŒ–æ¸¬é©—ç³»çµ±...');
    
    // åˆå§‹åŒ–äº‹ä»¶ç›£è½å™¨
    initEventListeners();
    
    // è¨­ç½®é è¨­æ¸¬é©—é¡å‹
    setQuestionType('simulate');
    
    // å»¶é²è¼‰å…¥é¡Œåº«ï¼Œç¢ºä¿æ‰€æœ‰scriptéƒ½å·²è¼‰å…¥
    setTimeout(() => {
        loadQuestionBanks();
        
        // å†æ¬¡æª¢æŸ¥é¡Œåº«ç‹€æ…‹
        setTimeout(() => {
            if (questionBank.length > 0) {
                console.log('âœ… é¡Œåº«åˆä½µæˆåŠŸï¼Œç¸½é¡Œæ•¸:', questionBank.length);
                // æ›´æ–°é¡Œç›®æ•¸é‡é™åˆ¶
                updateQuestionCountLimit();
            } else {
                console.error('âŒ é¡Œåº«åˆä½µå¤±æ•—ï¼Œè«‹æª¢æŸ¥ï¼š');
                console.error('1. 6å€‹é¡Œåº«æª”æ¡ˆæ˜¯å¦å­˜åœ¨');
                console.error('2. é¡Œåº«æª”æ¡ˆä¸­çš„è®Šæ•¸åç¨±æ˜¯å¦æ­£ç¢º');
                console.error('3. æª”æ¡ˆè·¯å¾‘æ˜¯å¦æ­£ç¢º');
                
                // é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯çµ¦ä½¿ç”¨è€…
                const errorMsg = document.createElement('div');
                errorMsg.className = 'error-message';
                errorMsg.innerHTML = 'é¡Œåº«è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥é¡Œåº«æª”æ¡ˆæ˜¯å¦å­˜åœ¨ä¸”æ ¼å¼æ­£ç¢º';
                document.querySelector('.container').insertBefore(errorMsg, document.querySelector('h1').nextSibling);
            }
        }, 1000);
        
    }, 100);
    
    console.log('æ¸¬é©—ç³»çµ±åˆå§‹åŒ–å®Œæˆ');
}

        // ç•¶é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–æ‡‰ç”¨
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>